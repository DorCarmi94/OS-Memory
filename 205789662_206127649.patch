diff --git a/Makefile b/Makefile
index 43e152f..94276b0 100644
--- a/Makefile
+++ b/Makefile
@@ -50,6 +50,10 @@ endif
 
 QEMU = qemu-system-riscv64
 
+ifndef SELECTION
+SELECTION := NONE
+endif
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
@@ -62,6 +66,7 @@ CFLAGS += -mcmodel=medany
 CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
 CFLAGS += -I.
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D $(SELECTION)
 
 # Disable PIE when possible (for Ubuntu 16.10 toolchain)
 ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
@@ -133,6 +138,8 @@ UPROGS=\
 	$U/_wc\
 	$U/_zombie\
 	$U/_lazytests\
+	$U/_tomer\
+	$U/_sometests\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/defs.h b/kernel/defs.h
index b7802e0..9d56844 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -110,6 +110,21 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+int             checkIfShouldSwap();
+int             addPageToProc(uint64,pagetable_t);
+int             freepage(uint64,pagetable_t);
+void            freePageToProc(int,int);
+int             CheckIfInFile(uint64);
+int             swapInFromDisk(int);
+void            enqueue(int);
+void            dequeue(int);
+void            printQueue();
+void            freeAllProcessMetaData();
+void            updateCounters();
+void            printPageFileTableStructForProc(struct proc *p);
+int             count_pages();
+int             pagefault();
+int             flipTrace();
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -181,6 +196,9 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 
+pte_t *         walk(pagetable_t, uint64, int );
+void            printPageFileTableStruct(pagetable_t);
+
 // plic.c
 void            plicinit(void);
 void            plicinithart(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 0e8762f..dd9444d 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -12,6 +12,7 @@ static int loadseg(pde_t *pgdir, uint64 addr, struct inode *ip, uint offset, uin
 int
 exec(char *path, char **argv)
 {
+  //printf("exec\n");
   char *s, *last;
   int i, off;
   uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase;
@@ -21,6 +22,10 @@ exec(char *path, char **argv)
   pagetable_t pagetable = 0, oldpagetable;
   struct proc *p = myproc();
 
+
+  struct pageFileTable tempKeepForBadDay;
+  tempKeepForBadDay=*p->pageFileTable;
+
   begin_op();
 
   if((ip = namei(path)) == 0){
@@ -38,6 +43,9 @@ exec(char *path, char **argv)
   if((pagetable = proc_pagetable(p)) == 0)
     goto bad;
 
+  //p->PageTablesInUse=0;
+
+  //printf("load program into memory\n");
   // Load program into memory.
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
     if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
@@ -74,7 +82,6 @@ exec(char *path, char **argv)
   uvmclear(pagetable, sz-2*PGSIZE);
   sp = sz;
   stackbase = sp - PGSIZE;
-
   // Push argument strings, prepare rest of stack in ustack.
   for(argc = 0; argv[argc]; argc++) {
     if(argc >= MAXARG)
@@ -111,16 +118,59 @@ exec(char *path, char **argv)
   // Commit to the user image.
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
+
+  
   p->sz = sz;
   p->trapframe->epc = elf.entry;  // initial program counter = main
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  //printf("size of proc in exec before adding: %d\n",p->sz);
+
+  #ifndef NONE
+    if(p->pid>2)
+    {
+      int newPagesIds[32];
+      int arrLength=0;
+      
+      freeAllProcessMetaData();
+
+      uint64 baseSz=0;
+      uint64 currSz;
+      uint64 procSz=PGROUNDUP(p->sz);
+      
+      for(currSz = baseSz; currSz < procSz; currSz += PGSIZE){
+        //printf("exec add page:\n");
+        pte_t *pte=walk(p->pagetable,currSz,0);
+        if((*pte&PTE_U)==0)
+        {
+          continue;
+        }
+        int pageID=addPageToProc(currSz,p->pagetable);
+        if(pageID<0)
+        {
+          for (int i = 0; i < arrLength; i++)
+          {
+              freePageToProc(newPagesIds[i],0);
+          }
+          panic("Add page to proc");
+        }
+      }
+      //printPageFileTableStruct(p->pagetable);
+    }
+  #endif
+  //printf("end of exec\n");
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
+ printf("bad exec\n");
+
   if(pagetable)
+  {
+    *p->pageFileTable=tempKeepForBadDay;
     proc_freepagetable(pagetable, sz);
+  }
+  
   if(ip){
     iunlockput(ip);
     end_op();
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..ceb7ecb 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -46,6 +46,7 @@ freerange(void *pa_start, void *pa_end)
 void
 kfree(void *pa)
 {
+  
   struct run *r;
 
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..aca5d14 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -1,13 +1,17 @@
-#define NPROC        64  // maximum number of processes
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
-#define MAXPATH      128   // maximum file path name
+#define NPROC               64  // maximum number of processes
+#define NCPU                8  // maximum number of CPUs
+#define NOFILE              16  // open files per process
+#define NFILE               100  // open files per system
+#define NINODE              50  // maximum number of active i-nodes
+#define NDEV                10  // maximum major device number
+#define ROOTDEV              1  // device number of file system root disk
+#define MAXARG              32  // max exec arguments
+#define MAXOPBLOCKS         10  // max # of blocks any FS op writes
+#define LOGSIZE             (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+#define NBUF                (MAXOPBLOCKS*3)  // size of disk block cache
+#define FSSIZE              1000  // size of file system in blocks
+#define MAXPATH             128   // maximum file path name
+#define MAX_PSYC_PAGES      16   // maximum pages in pyhsical memory
+#define MAX_TOTAL_PAGES     32   // maximum pages for process
+#define START_OF_QUEUE      -5000
+#define END_OF_QUEUE        5000
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..a717a85 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -119,6 +119,17 @@ allocproc(void)
 found:
   p->pid = allocpid();
   p->state = USED;
+  
+
+
+  //handle all about pages
+
+  p->pageIdxInHeadOfQueue=START_OF_QUEUE;
+  p->pageIdxInTailOfQueue=END_OF_QUEUE;
+  p->wasLastPageFault = 0;
+
+  p->pagePrintTraceOn=0;
+
 
   // Allocate a trapframe page.
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){
@@ -127,6 +138,7 @@ found:
     return 0;
   }
 
+
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
   if(p->pagetable == 0){
@@ -141,6 +153,41 @@ found:
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  if(p->pid>2)
+  {
+    release(&p->lock);
+
+    #ifndef NONE
+
+      createSwapFile(p);
+
+    #endif
+
+
+    acquire(&p->lock);
+    for(int i=0; i<MAX_TOTAL_PAGES; i++)
+    {
+      p->pageFileTable[i].fileLocation=0;
+      p->pageFileTable[i].isInFile=0;
+      p->pageFileTable[i].isInUse=0;
+      p->pageFileTable[i].pageNum=i;
+      p->pageFileTable[i].va=0;
+      
+      //SCFIFO
+      p->pageFileTable[i].nextLink=-1;
+      p->pageFileTable[i].prevLink=-1;
+
+      //NFU
+      p->pageFileTable[i].counter_NFU=0;
+      p->pageFileTable[i].counter_LA=0XFFFFFFFF;
+    }
+    p->PageTablesInUse=0;
+
+    for (int i = 0; i < MAX_PSYC_PAGES+1; i++)
+    {
+      p->fileAddressPool[i]=0;
+    }
+  }
   return p;
 }
 
@@ -155,6 +202,7 @@ freeproc(struct proc *p)
   p->trapframe = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
+  
   p->pagetable = 0;
   p->sz = 0;
   p->pid = 0;
@@ -247,14 +295,15 @@ userinit(void)
   release(&p->lock);
 }
 
+
+
 // Grow or shrink user memory by n bytes.
 // Return 0 on success, -1 on failure.
 int
 growproc(int n)
 {
   uint sz;
-  struct proc *p = myproc();
-
+  struct proc *p = myproc();  
   sz = p->sz;
   if(n > 0){
     if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
@@ -264,6 +313,8 @@ growproc(int n)
     sz = uvmdealloc(p->pagetable, sz, sz + n);
   }
   p->sz = sz;
+
+  //printPageFileTableStruct(p->pagetable);
   return 0;
 }
 
@@ -275,6 +326,8 @@ fork(void)
   int i, pid;
   struct proc *np;
   struct proc *p = myproc();
+  // printf("fork: p->number of pages: %d, p->sz: %d\n\n",p->PageTablesInUse,p->sz);
+  // printPageFileTableStructForProc(p);
 
   // Allocate process.
   if((np = allocproc()) == 0){
@@ -304,18 +357,59 @@ fork(void)
   safestrcpy(np->name, p->name, sizeof(p->name));
 
   pid = np->pid;
-
+  
   release(&np->lock);
 
   acquire(&wait_lock);
   np->parent = p;
   release(&wait_lock);
+  
+  if(np->pid>2)
+  {
+    for (i = 0; i < MAX_TOTAL_PAGES; i++)
+    {
+      np->pageFileTable[i].fileLocation=p->pageFileTable[i].fileLocation;
+      np->pageFileTable[i].isInFile=p->pageFileTable[i].isInFile;
+      np->pageFileTable[i].isInUse=p->pageFileTable[i].isInUse;
+      np->pageFileTable[i].va=p->pageFileTable[i].va;
+      np->pageFileTable[i].idxInFile=p->pageFileTable[i].idxInFile;
+
+      np->pageFileTable[i].nextLink=p->pageFileTable[i].nextLink;
+      np->pageFileTable[i].prevLink=p->pageFileTable[i].prevLink;
+
+      np->pageFileTable[i].counter_LA=p->pageFileTable[i].counter_LA;
+      np->pageFileTable[i].counter_NFU=p->pageFileTable[i].counter_NFU;
+
+      #ifndef NONE
+        if(p->pageFileTable[i].isInFile)
+        {
+          readFromSwapFile(p,np->buffer,p->pageFileTable[i].fileLocation,PGSIZE);
+          writeToSwapFile(np,np->buffer,np->pageFileTable[i].fileLocation,PGSIZE);
+        }
+      #endif
+    }
+
+    np->pageIdxInHeadOfQueue=p->pageIdxInHeadOfQueue;
+    np->pageIdxInTailOfQueue=p->pageIdxInTailOfQueue;
+
+    np->pagePrintTraceOn=p->pagePrintTraceOn;
+
+    np->PageTablesInUse=p->PageTablesInUse;
+    for (int i = 0; i < MAX_PSYC_PAGES+1; i++)
+    {
+      np->fileAddressPool[i]=p->fileAddressPool[i];
+    }
+
+    //printPageFileTableStructForProc(np);
+  }
 
   acquire(&np->lock);
   np->state = RUNNABLE;
   release(&np->lock);
-
+  //printf("end fork: np->number of pages: %d, np->sz: %d\n",np->PageTablesInUse,np->sz);
+  
   return pid;
+  
 }
 
 // Pass p's abandoned children to init.
@@ -353,11 +447,14 @@ exit(int status)
     }
   }
 
+  #ifndef NONE
+    removeSwapFile(p);
+  #endif
   begin_op();
   iput(p->cwd);
   end_op();
   p->cwd = 0;
-
+  
   acquire(&wait_lock);
 
   // Give any children to init.
@@ -498,6 +595,13 @@ yield(void)
   struct proc *p = myproc();
   acquire(&p->lock);
   p->state = RUNNABLE;
+  
+  #ifndef NONE
+    if(p->pid>2)
+    {
+      updateCounters();
+    }
+  #endif
   sched();
   release(&p->lock);
 }
@@ -654,3 +758,912 @@ procdump(void)
     printf("\n");
   }
 }
+
+//assumption: all pages in ram are in queue
+int scfifoChoose()
+{
+  struct proc *p=myproc();
+  if(p->pagePrintTraceOn==1)
+  {
+    printQueue();
+  }
+  
+  int currentPage=p->pageIdxInHeadOfQueue;
+  int firstInLoop=currentPage;
+  int firstTime=0;
+  while(1)
+  {
+    if(p->pageFileTable[currentPage].isInUse==0 || p->pageFileTable[currentPage].isInFile==1)
+    {
+      panic("scfifo choose: can't choose page not in use or in file1");
+    }
+    if(currentPage==START_OF_QUEUE || currentPage==END_OF_QUEUE)
+    {
+        panic("scfifo choose: Illegal current page");
+    }
+    
+    pte_t *pte=walk(p->pagetable,p->pageFileTable[currentPage].va,0);
+    if(pte==0)
+    {
+      panic("scfifo choose: no pte");
+    }
+    if(*pte&PTE_A)
+    {
+      //printf("page %d accessed, his next is: %d, his prev is: %d\n",currentPage,p->pageFileTable[currentPage].nextLink,p->pageFileTable[currentPage].prevLink);
+      if(firstTime!=0 && currentPage==firstInLoop)
+      {
+        panic("scfifo choose: full loop");
+      }
+      *pte&=~PTE_A;
+
+      dequeue(currentPage);
+      enqueue(currentPage);
+      if(p->pagePrintTraceOn)
+      {
+        printQueue();
+      }
+
+      // printf("after enqueue and dequeue\n");
+      // printQueue();
+      // printf("\n");
+      
+      currentPage=p->pageIdxInHeadOfQueue;
+      firstTime=1;
+    }
+    else
+    {
+      return currentPage;
+    }
+  }
+  
+}
+
+void print64Binary(uint64 number)
+{
+  uint64 currnumber=number;
+  for (int i = 0; i < 64; i++)
+  {
+    uint64 check=currnumber&(1L<<63);
+    if(check==0)
+    {
+      printf("0");
+    }
+    else
+    {
+      printf("1");
+    }
+    currnumber=(uint64)(currnumber<<1);
+  }
+  printf("\n");
+  
+}
+
+void PrintNFUcounters()
+{
+  struct proc *p=myproc();
+  printf("---NFU Counters:---------\n");
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse==1)
+    {
+      if(p->pageFileTable[i].isInFile==0)
+      {
+        printf("Page %d NFU counter: \t",i);
+        print64Binary(p->pageFileTable[i].counter_NFU);
+      }
+      else
+      {
+        printf("Page %d: IN FILE\n",i);
+      }
+    }
+  }
+  printf("---------------------\n");
+}
+
+
+void PrintLAPAcounters()
+{
+  struct proc *p=myproc();
+  printf("---LAPA Counters:---------\n");
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse==1)
+    {
+      if(p->pageFileTable[i].isInFile==0)
+      {
+        printf("Page %d LAPA counter: \t",i);
+        print64Binary(p->pageFileTable[i].counter_LA);
+      }
+      else
+      {
+        printf("Page %d: IN FILE\n",i);
+      }
+    }
+  }
+  printf("---------------------\n");
+}
+
+
+void printQueue()
+{
+  struct proc *p=myproc();
+  int count=0;
+  //printf("--------- The queue:------------\n");
+  int currentPageIdx=p->pageIdxInHeadOfQueue;
+  printf("HEAD -> ");
+  while(currentPageIdx!=END_OF_QUEUE && count<MAX_PSYC_PAGES)
+  {
+    printf("%d -> ",currentPageIdx);
+    currentPageIdx=p->pageFileTable[currentPageIdx].nextLink;
+    count++;
+  }
+  printf("TAIL\n");
+  //printf("--------------------------------\n\n");
+
+
+}
+
+int NFU_choose()
+{
+  struct proc *p=myproc();
+  
+  int isFirst=1;
+  
+  int minCounter;
+  int minCounterIdx=-1;
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse==1 && p->pageFileTable[i].isInFile==0)
+    {
+      if(isFirst)
+      {
+        minCounter=p->pageFileTable[i].counter_NFU;
+        minCounterIdx=i;
+      }
+      else
+      {
+        if(p->pageFileTable[i].counter_NFU<minCounter)
+        {
+          minCounter=p->pageFileTable[i].counter_NFU;
+          minCounterIdx=i;
+        }
+      }
+      
+    }
+  }
+
+  return minCounterIdx;
+}
+
+
+int countOnes(int number)
+{
+  int tempNum=number;
+  int counter=0;
+  for (int i = 0; i < 64; i++)
+  {
+    if((tempNum&1)==1)
+    {
+      counter++;
+    }
+    tempNum=tempNum>>1;
+  }
+  return counter;
+}
+
+
+int LAPA_choose2()
+{
+  struct proc *p=myproc();
+  
+  int isFirst=1;
+  
+  int minOnes;
+  int minCounter;
+  int minIdx=-1;
+
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse==1 && p->pageFileTable[i].isInFile==0)
+    {
+      if(isFirst)
+      {
+        minOnes=countOnes(p->pageFileTable[i].counter_LA);
+        minCounter=p->pageFileTable[i].counter_LA;
+        minIdx=i;
+      }
+      else
+      {
+        int currOnes=countOnes(p->pageFileTable[i].counter_LA);
+        if(currOnes<minOnes)
+        {
+          minOnes=currOnes;
+          minIdx=i;
+          minCounter=p->pageFileTable[i].counter_LA;
+        }
+        else if (currOnes==minOnes)
+        {
+          if(p->pageFileTable[i].counter_LA<minCounter)
+          {
+            minOnes=currOnes;
+            minIdx=i;
+            minCounter=p->pageFileTable[i].counter_LA;
+          }
+        }
+      }
+    }
+  }
+  return minIdx;
+
+}
+
+int LAPA_choose()
+{
+  struct proc *p=myproc();
+  
+  int isFirst=1;
+  int allTheSame=1;
+  
+  int minCounter;
+  int minOnesCounter;
+  int minCounterIdx=-1;
+  int minOnesCounterIdx=-1;
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse==1 && p->pageFileTable[i].isInFile==0)
+    {
+      if(isFirst)
+      {
+        minCounter=p->pageFileTable[i].counter_NFU;
+        minCounterIdx=i;
+        minOnesCounter=countOnes(p->pageFileTable[i].counter_LA);
+        minOnesCounterIdx=i;
+      }
+      else
+      {
+        if(allTheSame)
+        {
+          if(countOnes(p->pageFileTable[i].counter_LA)==minOnesCounter)
+          {
+            if(p->pageFileTable[i].counter_LA<minCounter)
+            {
+              minCounter=p->pageFileTable[i].counter_LA;
+              minCounterIdx=i;
+            }
+          }
+          else
+          {
+            allTheSame=0;
+          }
+        }
+        
+        if(allTheSame==0)
+        {
+          if(countOnes(p->pageFileTable[i].counter_LA)<minOnesCounter)
+          {
+            minOnesCounter=countOnes(p->pageFileTable[i].counter_LA);
+            minOnesCounterIdx=i;
+          }
+        }
+      }
+      
+    }
+  }
+  if(allTheSame==1)
+  {
+    return minCounterIdx;
+  }
+  else
+  {
+    return minOnesCounterIdx;
+  }
+}
+
+
+
+//Swap out from memory
+int choosePageNumToSwap()
+{
+  #ifdef NONE
+    return -1;
+
+  #else
+
+  #ifdef SCFIFO
+    return scfifoChoose();
+
+  #else
+
+  #ifdef NFUA
+    return NFU_choose();
+
+  #else
+  
+  #ifdef LAPA
+    return LAPA_choose2();
+
+  #endif
+  #endif
+  #endif
+  #endif
+
+  
+}
+
+
+//swap out from ram to disk only
+int swapOut()
+{
+  struct proc *p=myproc();
+  p->wasLastPageFault = 1;
+
+  int pageNumInOurStructToSwap=choosePageNumToSwap(); // choose number of page to move to disk
+  if(p->pagePrintTraceOn)
+  {
+    printf("swap out: choosing page number %d to swap out\n",pageNumInOurStructToSwap);
+  }
+  if(pageNumInOurStructToSwap<0)
+  {
+    panic("Page fault in swap");
+  }
+
+  dequeue(pageNumInOurStructToSwap);
+
+  
+
+  #ifdef SCFIFO
+  if(p->pagePrintTraceOn)
+  {
+    printQueue();
+  }
+  #endif
+  
+  uint64 theVAtoChange=p->pageFileTable[pageNumInOurStructToSwap].va;
+  
+  uint64 pa=walkaddr(p->pagetable,theVAtoChange); //pa of page on ram
+
+  if(pa<=0)
+  {
+    panic ("walk in swap");
+  }
+
+  int fileAddr=-1;
+  //Find free location insdie the file (on disk)
+  for (int i = 0; i < MAX_PSYC_PAGES+1 && fileAddr==-1; i++)
+  {
+    if(p->fileAddressPool[i]!=1)
+    {
+      p->fileAddressPool[i]=1;
+      fileAddr=PGSIZE*i;
+      p->pageFileTable[pageNumInOurStructToSwap].fileLocation=fileAddr;
+      p->pageFileTable[pageNumInOurStructToSwap].idxInFile=i;
+    }
+  }
+  if(fileAddr<0)
+  {
+    printPageFileTableStruct(p->pagetable);
+    panic("no place on file2");
+  }
+  
+  writeToSwapFile(p,(char*)pa,fileAddr,PGSIZE);
+  
+  p->pageFileTable[pageNumInOurStructToSwap].isInFile=1;
+  kfree((void *)pa);
+  
+  pte_t* pte=walk(p->pagetable,theVAtoChange,0);
+  *pte |=PTE_PG;
+  *pte &= ~PTE_V;
+
+  
+  return pageNumInOurStructToSwap;
+}
+
+
+int checkIfNeedToSwapOut()
+{
+  struct proc *p=myproc();
+  int isThereNeedToSwapOut=0;
+
+  int countRAM=0;
+
+  for (int i = 0; i < MAX_TOTAL_PAGES && isThereNeedToSwapOut==0; i++)
+  {
+    if(countRAM+1==MAX_PSYC_PAGES)
+    {
+      isThereNeedToSwapOut=1;
+    }
+    else
+    {
+      if(p->pageFileTable[i].isInUse==0)
+      {
+        isThereNeedToSwapOut=0;
+      }
+      else
+      {
+        if(p->pageFileTable[i].isInFile==0)
+        {
+          countRAM++;
+        }
+      }
+    }
+  }
+  return isThereNeedToSwapOut;
+}
+
+//the argument is the number of page we need, that we wan't to bring from the disk
+int swapInFromDisk(int pageIdxInProc)
+{
+  
+  struct proc *p=myproc();
+  
+  
+
+  if(checkIfNeedToSwapOut())
+  {
+  //write
+    swapOut();
+  }
+
+  //read page in and free page in file
+  char *mem;
+  mem = kalloc();
+  if(mem == 0){
+    panic("not enough memory in swap in");
+  }
+  memset(mem, 0, PGSIZE);
+  pte_t *pteToGetFromDisk=walk(p->pagetable,p->pageFileTable[pageIdxInProc].va,0);
+  if(pteToGetFromDisk==0)
+  {
+    panic("not pte for page in swap in");
+  }
+  uint perm=PTE_FLAGS(*pteToGetFromDisk);
+  perm |=PTE_V;
+  perm &= ~PTE_PG;
+
+  *pteToGetFromDisk = PA2PTE(mem) | perm;
+  uint fileLocationOfPageThatWeBringBackFromDisk=p->pageFileTable[pageIdxInProc].fileLocation;
+
+  int ansRead=readFromSwapFile(p,mem,fileLocationOfPageThatWeBringBackFromDisk,PGSIZE);
+  if(ansRead<0)
+  {
+    panic("read page back swap in");
+  }
+  p->pageFileTable[pageIdxInProc].isInFile=0;
+  int idxInAddressPool=p->pageFileTable[pageIdxInProc].idxInFile;
+  p->fileAddressPool[idxInAddressPool]=0;
+  
+  enqueue(pageIdxInProc);
+
+  p->pageFileTable[pageIdxInProc].counter_NFU=0;
+  p->pageFileTable[pageIdxInProc].counter_LA=-1;
+
+  return 1;
+}
+
+
+// -1   : error
+// 100  : temp page added by exec, no need to add to meta data
+int 
+addPageToProc(uint64 va, pagetable_t pagetable)
+{
+  
+  struct proc *p=myproc();
+  //printPageFileTableStruct(p->pagetable);
+  
+
+  if(p->pid<3)
+  {
+    return 100;
+  }
+
+  //printf("pid: %d, page tables: %d\n",p->pid,p->PageTablesInUse);
+  if(p->pagePrintTraceOn==1)
+  {
+    printf("adding new page to process: %d\n\n",p->PageTablesInUse);
+  }  
+  //printf("pid: %d, pages in use: %d, va: %d\n",p->pid,p->PageTablesInUse,va);
+  if(p->PageTablesInUse>=MAX_TOTAL_PAGES)
+  {
+    panic("Too many pages in proc");
+  }
+  int pageToAdd=-1;
+
+  #ifdef SCFIFO
+  if(p->pagePrintTraceOn)
+  {
+    printf("-----Queue changes:-------\n");
+  }
+  #endif
+
+  if(p->pagetable==pagetable)
+  {
+    if(p->PageTablesInUse>=MAX_PSYC_PAGES)
+    {
+      if(checkIfNeedToSwapOut())
+      {
+      
+        swapOut();
+      }
+    }
+    
+    for (int i = 0; i < MAX_TOTAL_PAGES && pageToAdd==-1; i++)
+    {
+      if(p->pageFileTable[i].isInUse==0)
+      {
+        pageToAdd=i;        
+      }
+    }
+
+    if(pageToAdd<0)
+    {
+      panic("Swap logic");
+    }
+    p->pageFileTable[pageToAdd].isInUse=1;
+    p->pageFileTable[pageToAdd].isInFile=0;
+    p->pageFileTable[pageToAdd].va=va;
+    p->PageTablesInUse+=1;
+  }
+  else
+  {
+    // of exec, new pagetable, the pages will be added later
+    pageToAdd=100;
+  }
+  
+
+  //only for scfifo
+  if(pageToAdd!=-1 && pageToAdd!=100)
+  {
+    
+    enqueue(pageToAdd);
+    #ifdef SCFIFO
+    if(p->pagePrintTraceOn)
+    {
+      printQueue();
+      printf("-----End of Queue changes:-------\n");
+    }
+    #endif
+    p->pageFileTable[pageToAdd].counter_NFU=0;
+    p->pageFileTable[pageToAdd].counter_LA=-1;
+  }
+  // printQueue("\n----Queue after add----\n");
+  // printQueue();
+  return pageToAdd;
+}
+
+
+void printPageFileTableStructForProc(struct proc *p)
+{
+  printf("**************************\n");
+  if(p->pid>=3)
+  {
+    for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+    {
+      
+      int currPa=walkaddr(p->pagetable,p->pageFileTable[i].va);
+      pte_t *pte=walk(p->pagetable,p->pageFileTable[i].va,0);
+      //printf("Calling walkaddr with: va: %p, currPa: %p\n",p->pageFileTable[i].va,currPa);
+      printf("Page number: %d, current physical address: %p, va: %p, isInUse: %d, isInFile: %d, location in file: %p, PTE_PG: %d, PTE_V: %d\n",i,currPa,p->pageFileTable[i].va/PGSIZE, p->pageFileTable[i].isInUse,p->pageFileTable[i].isInFile, p->pageFileTable[i].fileLocation, (*pte&PTE_PG),(*pte&PTE_V));
+    }
+    
+  }
+  printf("**************************\n");
+}
+
+void printPageFileTableStruct(pagetable_t pagetable)
+{
+  printf("**************************\n");
+  struct proc *p=myproc();
+  if(p->pid>=3)
+  {
+    for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+    {
+      
+      int currPa=walkaddr(p->pagetable,p->pageFileTable[i].va);
+      pte_t *pte=walk(p->pagetable,p->pageFileTable[i].va,0);
+      //printf("Calling walkaddr with: va: %p, currPa: %p\n",p->pageFileTable[i].va,currPa);
+      printf("Page number: %d, current physical address: %p, va: %p, isInUse: %d, isInFile: %d, location in file: %p, PTE_PG: %d, PTE_V: %d\n",i,currPa,p->pageFileTable[i].va/PGSIZE, p->pageFileTable[i].isInUse,p->pageFileTable[i].isInFile, p->pageFileTable[i].fileLocation, (*pte&PTE_PG),(*pte&PTE_V));
+    }
+    
+  }
+  printf("**************************\n");
+}
+
+void 
+freePageToProc(int procPageID, int isFromExec)
+{
+  //printf("free to proc: %d\n",procPageID);
+  struct proc *p=myproc();
+  if(p->pid<3)
+  {
+    return;
+  }
+  if(procPageID>31 || procPageID<0)
+  {
+    panic("free page to proc");
+  }
+  
+  if(!isFromExec && p->pageFileTable[procPageID].isInUse==0)
+  {
+    panic("freeing proc not in use");
+  }
+  if(p->pageFileTable[procPageID].isInFile)
+  {
+    int idxInPool=p->pageFileTable[procPageID].idxInFile;
+    //printf("free page pool idx: %d\n",idxInPool);
+    p->fileAddressPool[idxInPool]=0;
+  }
+  else
+  {
+    //not in file, in ram
+    //scfifo
+    if(!isFromExec)
+    {
+      dequeue(procPageID);
+    }
+  }
+  p->pageFileTable[procPageID].isInUse=0;
+  p->pageFileTable[procPageID].fileLocation=0;
+  p->pageFileTable[procPageID].isInFile=0;
+  p->pageFileTable[procPageID].va=0;
+  p->pageFileTable[procPageID].nextLink=-1;
+  p->pageFileTable[procPageID].prevLink=-1;
+  p->pageFileTable[procPageID].counter_LA=-1;
+  p->pageFileTable[procPageID].counter_NFU=0;
+}
+
+int freepage(uint64 va, pagetable_t pagetable)
+{
+  struct proc *p=myproc();
+  if(pagetable!=p->pagetable)
+  {
+    return 1;
+  }
+  if(p->pid>2)
+  {
+    if(p->PageTablesInUse==0)
+    {
+      printf("pid: %d\n",p->pid);
+      panic("Pages in process under zero");
+    }
+    int found=-1;
+    for (int i = 0; i < MAX_TOTAL_PAGES && found!=1; i++)
+    {
+      if(p->pageFileTable[i].va== va && p->pageFileTable[i].isInUse == 1)
+      {
+        freePageToProc(i,0);
+        found=1;
+      }
+    }
+    if(found==1)
+    {
+      p->PageTablesInUse-=1;
+    }
+    return found;
+  }
+  return 0;  
+}
+
+
+int CheckIfInFile(uint64 va)
+{
+  struct proc *p=myproc();
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].va==va)
+    {
+      if(p->pageFileTable[i].isInUse && p->pageFileTable[i].isInFile)
+      {
+        return 1;
+      }
+      else if(p->pageFileTable[i].isInUse)
+      {
+        return 0;
+      }
+      else
+      {
+        return -1;
+      }      
+    }
+  }
+  return -1;
+}
+
+void enqueue(int pageIdxInMetaData)
+{
+  struct proc *p=myproc();
+
+  if(p->pageFileTable[pageIdxInMetaData].isInFile==0)
+  {
+  //pagelinks explain:
+      //  5000   : points to the end of the queue
+      // -5000   : points to the head of the queue
+      if(p->pageIdxInHeadOfQueue==START_OF_QUEUE && p->pageIdxInTailOfQueue==END_OF_QUEUE)
+      {
+        //Page added to queue when it is empty
+        p->pageIdxInHeadOfQueue=pageIdxInMetaData;
+        p->pageIdxInTailOfQueue=pageIdxInMetaData;
+        p->pageFileTable[pageIdxInMetaData].nextLink=END_OF_QUEUE;
+        p->pageFileTable[pageIdxInMetaData].prevLink=START_OF_QUEUE;
+        //printf("page %d is first in queue: next: %d, prev: %d\n",pageIdxInMetaData,
+        //p->pageFileTable[pageIdxInMetaData].nextLink,p->pageFileTable[pageIdxInMetaData].prevLink);
+      }
+      else if(p->pageIdxInTailOfQueue==START_OF_QUEUE || p->pageIdxInHeadOfQueue==END_OF_QUEUE)
+      {
+        panic("scfifo queue logic");
+      }
+      else
+      {
+        int currentPageInTheEndOfTheQueue=p->pageIdxInTailOfQueue;
+        if(currentPageInTheEndOfTheQueue==-1)
+        {
+          panic("scfifo queue, not suppose to be empty");
+        }
+        p->pageFileTable[currentPageInTheEndOfTheQueue].nextLink=pageIdxInMetaData;
+        p->pageIdxInTailOfQueue=pageIdxInMetaData;
+        p->pageFileTable[pageIdxInMetaData].nextLink=END_OF_QUEUE;
+        p->pageFileTable[pageIdxInMetaData].prevLink=currentPageInTheEndOfTheQueue;
+
+       // printf("new page to process %d is in queue: next: %d, prev: %d\n",pageIdxInMetaData,
+        //p->pageFileTable[pageIdxInMetaData].nextLink,p->pageFileTable[pageIdxInMetaData].prevLink);
+
+       // printf("page that was in tail %d is in queue: next: %d, prev: %d\n",currentPageInTheEndOfTheQueue,
+        //p->pageFileTable[currentPageInTheEndOfTheQueue].nextLink,p->pageFileTable[currentPageInTheEndOfTheQueue].prevLink);
+      }
+  }
+}
+
+void dequeue(int pageIdxInMetaData)
+{
+    struct proc *p=myproc();
+    
+    int prevToThisPage=p->pageFileTable[pageIdxInMetaData].prevLink;
+    int nextToThisPage=p->pageFileTable[pageIdxInMetaData].nextLink;
+
+    //printf("prev of page %d is %d\n",pageIdxInMetaData,prevToThisPage);
+    
+    if(prevToThisPage==START_OF_QUEUE && nextToThisPage==END_OF_QUEUE)
+    {
+      //the only one in the queue
+      p->pageIdxInHeadOfQueue=START_OF_QUEUE;
+      p->pageIdxInTailOfQueue=END_OF_QUEUE;
+    }
+    else if(prevToThisPage==START_OF_QUEUE)
+    {
+      
+      p->pageFileTable[nextToThisPage].prevLink=START_OF_QUEUE;
+      p->pageIdxInHeadOfQueue=nextToThisPage;
+    }
+    else if(prevToThisPage==END_OF_QUEUE)
+    {
+      
+      p->pageFileTable[prevToThisPage].nextLink=END_OF_QUEUE;
+      p->pageIdxInTailOfQueue=prevToThisPage;
+    }
+    else
+    {
+      p->pageFileTable[prevToThisPage].nextLink=nextToThisPage;
+      p->pageFileTable[nextToThisPage].prevLink=prevToThisPage;
+    }    
+}
+
+void freeAllProcessMetaData()
+{
+  struct proc *p=myproc();
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    freePageToProc(i,1);
+  }
+  
+  p->PageTablesInUse=0;
+  removeSwapFile(p);
+  createSwapFile(p);
+  p->pageIdxInHeadOfQueue=START_OF_QUEUE;
+  p->pageIdxInTailOfQueue=END_OF_QUEUE;
+
+}
+
+
+
+void updateNFU()
+{
+  struct proc *p=myproc();
+  if(p->pid<3)
+  {
+    return;
+  }
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse && p->pageFileTable[i].isInFile==0)
+    {
+      pte_t *pte=walk(p->pagetable,p->pageFileTable[i].va,0);
+      if(pte==0)
+      {
+        panic("update counters: no pte");
+      }
+      p->pageFileTable[i].counter_NFU = p->pageFileTable[i].counter_NFU >> 1;
+      if(*pte&PTE_A)
+      {
+        p->pageFileTable[i].counter_NFU |= (1L<<63);
+        *pte &= ~PTE_A;
+      }
+    }
+  }
+  #ifdef NFUA
+  if(p->pagePrintTraceOn==1)
+  {
+    PrintNFUcounters();
+  }
+  #endif
+}
+
+void updateLAPA()
+{
+  struct proc *p=myproc();
+  if(p->pid<3)
+  {
+    return;
+  }
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    if(p->pageFileTable[i].isInUse && p->pageFileTable[i].isInFile==0)
+    {
+      pte_t *pte=walk(p->pagetable,p->pageFileTable[i].va,0);
+      if(pte==0)
+      {
+        panic("update counters: no pte");
+      }
+      p->pageFileTable[i].counter_LA =(uint64) (p->pageFileTable[i].counter_LA >> 1);
+      if(*pte&PTE_A)
+      {
+        p->pageFileTable[i].counter_LA |= (uint64)(1L<<63);
+        *pte &= ~PTE_A;
+      }
+      //printf("counter lapa for page %d: %p\n",i,p->pageFileTable[i].counter_LA);
+    }
+  }
+  #ifdef LAPA
+  if(p->pagePrintTraceOn)
+  {
+    PrintLAPAcounters();
+  }
+  #endif
+}
+
+void
+updateCounters()
+{
+  updateNFU();
+  updateLAPA();  
+}
+
+int
+count_pages(){
+  struct proc *p = myproc();
+  return p->PageTablesInUse;
+}
+
+int
+pagefault(){
+  struct proc *p = myproc();
+  int last = p->wasLastPageFault;
+  p->wasLastPageFault=0;
+  return last;
+}
+
+int
+flipTrace()
+{
+  struct proc *p=myproc();
+  if(p->pagePrintTraceOn==0)
+  {
+    p->pagePrintTraceOn=1;
+    printf("trace %d\n",p->pagePrintTraceOn);
+  }
+  else
+  {
+    p->pagePrintTraceOn=0;
+  }
+  return p->pagePrintTraceOn;
+  
+
+}
\ No newline at end of file
diff --git a/kernel/proc.h b/kernel/proc.h
index c007999..16975ba 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -18,6 +18,25 @@ struct context {
   uint64 s11;
 };
 
+struct pageFileTable
+{
+  int isInFile;               // Indicates if the page is in the file or not
+  int isInUse;
+  uint64 va;
+  uint pageNum;               // Index of page
+  uint fileLocation;          // Location of page in the process's file
+  int idxInFile;
+  
+
+  //SCFIFO
+  int nextLink;
+  int prevLink;
+  
+  //NFU
+  uint64 counter_NFU;
+  uint64 counter_LA;
+};
+
 // Per-CPU state.
 struct cpu {
   struct proc *proc;          // The process running on this cpu, or null.
@@ -106,5 +125,18 @@ struct proc {
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
 
+
+
+  int PageTablesInUse;                  // Number of PTES currently in use
+  struct pageFileTable pageFileTable[MAX_TOTAL_PAGES];   // Table for all pages that are not in RAM but in file on disk 
+  int fileAddressPool[MAX_PSYC_PAGES+1];
+  char buffer[PGSIZE*MAX_TOTAL_PAGES];
+
+  int pageIdxInHeadOfQueue;
+  int pageIdxInTailOfQueue;
   struct file *swapFile;
+
+  int wasLastPageFault;
+
+  int pagePrintTraceOn;
 };
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 0aec003..ca6567a 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -330,7 +330,9 @@ sfence_vma()
 #define PTE_R (1L << 1)
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
+#define PTE_A (1L << 6) //1-> accessed, Rbit
 #define PTE_U (1L << 4) // 1 -> user can access
+#define PTE_PG (1L << 9) // 1-> Page out to secondary storage
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..510518c 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,29 +104,35 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_count_pages(void);
+extern uint64 sys_pagefault(void);
+extern uint64 sys_flipPageTracePrintFlag(void);
 
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+[SYS_fork]         sys_fork,
+[SYS_exit]         sys_exit,
+[SYS_wait]         sys_wait,
+[SYS_pipe]         sys_pipe,
+[SYS_read]         sys_read,
+[SYS_kill]         sys_kill,
+[SYS_exec]         sys_exec,
+[SYS_fstat]        sys_fstat,
+[SYS_chdir]        sys_chdir,
+[SYS_dup]          sys_dup,
+[SYS_getpid]       sys_getpid,
+[SYS_sbrk]         sys_sbrk,
+[SYS_sleep]        sys_sleep,
+[SYS_uptime]       sys_uptime,
+[SYS_open]         sys_open,
+[SYS_write]        sys_write,
+[SYS_mknod]        sys_mknod,
+[SYS_unlink]       sys_unlink,
+[SYS_link]         sys_link,
+[SYS_mkdir]        sys_mkdir,
+[SYS_close]        sys_close,
+[SYS_count_pages]  sys_count_pages,
+[SYS_pagefault]    sys_pagefault,
+[SYS_flipPageTracePrintFlag]    sys_flipPageTracePrintFlag,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..fd07891 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -1,22 +1,25 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
-#define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
-#define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
-#define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#define SYS_fork          1
+#define SYS_exit          2
+#define SYS_wait          3
+#define SYS_pipe          4
+#define SYS_read          5
+#define SYS_kill          6
+#define SYS_exec          7
+#define SYS_fstat         8
+#define SYS_chdir         9
+#define SYS_dup          10
+#define SYS_getpid       11
+#define SYS_sbrk         12
+#define SYS_sleep        13
+#define SYS_uptime       14
+#define SYS_open         15
+#define SYS_write        16
+#define SYS_mknod        17
+#define SYS_unlink       18
+#define SYS_link         19
+#define SYS_mkdir        20
+#define SYS_close        21
+#define SYS_count_pages  22
+#define SYS_pagefault    23
+#define SYS_flipPageTracePrintFlag    24
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..3433739 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -23,6 +23,12 @@ sys_getpid(void)
   return myproc()->pid;
 }
 
+uint64
+sys_flipPageTracePrintFlag(void)
+{
+  return flipTrace();
+}
+
 uint64
 sys_fork(void)
 {
@@ -49,6 +55,7 @@ sys_sbrk(void)
   addr = myproc()->sz;
   if(growproc(n) < 0)
     return -1;
+  //printf("return add\n");
   return addr;
 }
 
@@ -95,3 +102,15 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_count_pages(void)
+{
+  return count_pages();
+}
+
+uint64
+sys_pagefault(void)
+{
+  return pagefault();
+}
\ No newline at end of file
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..821fc5a 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -37,6 +37,7 @@ void
 usertrap(void)
 {
   int which_dev = 0;
+  //uint64 missedPA=0;  //Missed physical address
 
   if((r_sstatus() & SSTATUS_SPP) != 0)
     panic("usertrap: not from user mode");
@@ -49,8 +50,71 @@ usertrap(void)
   
   // save user program counter.
   p->trapframe->epc = r_sepc();
+
+  #ifndef NONE
+
+    uint64 missedVA=0;  //Missed virtual address
+    int chosenProcPageIdx=-1;
+
+    uint cause=r_scause();
+    if(cause==13 || cause==12 || cause==15)
+    {
+        
+        missedVA= r_stval();
+
+        pte_t *pte=walk(p->pagetable,missedVA,0);
+        if((*pte&PTE_PG)!=0)
+        {
+          for (int i = 0; i <MAX_TOTAL_PAGES && chosenProcPageIdx==-1; i++)
+          {
+            if(p->pageFileTable[i].va==PGROUNDDOWN(missedVA))
+            {
+              chosenProcPageIdx=i;
+            }
+          }
+          if(chosenProcPageIdx==-1)
+          {
+            printf("We are killing the process\n");
+            p->killed=1;
+          }
+          else
+          {
+            if(p->pagePrintTraceOn==1)
+            {
+              printf("Page fault: %d\n",chosenProcPageIdx);
+            }
+            #ifdef SCFIFO
+            if(p->pagePrintTraceOn)
+            {
+              printf("-----Queue changes:-------\n");
+            }
+            #endif
+            swapInFromDisk(chosenProcPageIdx);
+            #ifdef SCFIFO
+            if(p->pagePrintTraceOn)
+            {
+              printf("-----End of Queue changes:-------\n");
+            }
+            #endif
+          }
+        }
+        else
+        {
+          //printPageFileTableStruct(p->pagetable);
+          printf("stval: %p, cause: %d, PTE_V: %d, PTE_PG: %d\n",missedVA,cause,(*pte&PTE_V),(*pte&PTE_PG));
+          panic("pagefault");
+        }
+        
+        //printf("missing physical address: %p\n",missedPA);
+        //panic("simba");
+    }
   
+
+  else if(r_scause() == 8){
+    
+  #else
   if(r_scause() == 8){
+  #endif
     // system call
 
     if(p->killed)
diff --git a/kernel/vm.c b/kernel/vm.c
index b47f111..715d835 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -111,11 +111,17 @@ walkaddr(pagetable_t pagetable, uint64 va)
 
   pte = walk(pagetable, va, 0);
   if(pte == 0)
+  {
     return 0;
+  }
   if((*pte & PTE_V) == 0)
+  {
     return 0;
+  }
   if((*pte & PTE_U) == 0)
+  {
     return 0;
+  }
   pa = PTE2PA(*pte);
   return pa;
 }
@@ -171,13 +177,35 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
   for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
     if((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
+
+
+  #ifndef NONE
+    if(((*pte & PTE_V) == 0) && ((*pte & PTE_PG) == 0))
+      panic("uvmunmap: not mapped");
+  #else
     if((*pte & PTE_V) == 0)
       panic("uvmunmap: not mapped");
+  #endif
+
+
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
     if(do_free){
-      uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
+      #ifndef NONE
+        if(*pte & PTE_U)
+        {
+          freepage(a,pagetable);
+        }
+        if(!(*pte & PTE_PG))
+        {
+            uint64 pa = PTE2PA(*pte);
+            kfree((void*)pa);
+        }
+      #else
+          uint64 pa = PTE2PA(*pte);
+          kfree((void*)pa);
+      #endif
+            
     }
     *pte = 0;
   }
@@ -212,26 +240,70 @@ uvminit(pagetable_t pagetable, uchar *src, uint sz)
   memmove(mem, src, sz);
 }
 
+
 // Allocate PTEs and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 uint64
 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 {
+  
+  //printf("uvmalloc: oldsz: %d, newsz: %d\n",oldsz,newsz);
   char *mem;
   uint64 a;
 
+  int newPagesIds[32];
+  int arrLength=0;
   if(newsz < oldsz)
     return oldsz;
-
+    
   oldsz = PGROUNDUP(oldsz);
   for(a = oldsz; a < newsz; a += PGSIZE){
+    #ifndef NONE
+      int procPageId=addPageToProc(a, pagetable);
+      if(procPageId<0)
+      {
+        printf("bad 1\n");
+        for (int i = 0; i < arrLength; i++)
+        {
+            freePageToProc(newPagesIds[i],0);
+        }
+        panic("Add page to proc");
+        //free proc
+      }
+      if(procPageId!=100)
+      {
+        newPagesIds[arrLength]=procPageId;
+        arrLength++;
+      }
+
+    #else
+      newPagesIds[arrLength]=0;
+      if(newPagesIds[0]>1)
+      {
+        newPagesIds[0]=2;
+      }
+      arrLength++;
+    #endif
+    
     mem = kalloc();
     if(mem == 0){
+      #ifndef NONE
+        for (int i = 0; i < arrLength; i++)
+        {
+            freePageToProc(newPagesIds[i],0);
+        }
+      #endif
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
     memset(mem, 0, PGSIZE);
     if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
+      #ifndef NONE
+        for (int i = 0; i < arrLength; i++)
+        {
+            freePageToProc(newPagesIds[i],0);
+        }
+      #endif
       kfree(mem);
       uvmdealloc(pagetable, a, oldsz);
       return 0;
@@ -247,6 +319,7 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 uint64
 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 {
+  printf("dealloc, newsz: %d, oldsz: %d\n",newsz,oldsz);
   if(newsz >= oldsz)
     return oldsz;
 
@@ -254,7 +327,6 @@ uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
     int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
     uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
   }
-
   return newsz;
 }
 
@@ -301,12 +373,24 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   uint64 pa, i;
   uint flags;
   char *mem;
-
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+    {
+      #ifndef NONE
+        if((*pte & PTE_PG) != 0)
+        {
+            //OK, move on
+        }
+        else
+        {
+          panic("uvmcopy: page not present");
+        }
+      #else
+        panic("uvmcopy: page not present");
+      #endif
+    }
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
@@ -316,10 +400,18 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
       kfree(mem);
       goto err;
     }
+    #ifndef NONE
+      pte_t *pteNew= walk(new,i,0);
+      if(((*pte&PTE_U)!=0) && ((*pte&PTE_V)==0))
+      {
+        *pteNew &= ~PTE_V;
+      }
+    #endif
   }
   return 0;
 
  err:
+  printf("uvcopy error\n");
   uvmunmap(new, 0, i / PGSIZE, 1);
   return -1;
 }
diff --git a/user/sh.c b/user/sh.c
index 83dd513..b35a1a2 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -75,6 +75,7 @@ runcmd(struct cmd *cmd)
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
       exit(1);
+    //printf("calling exec\n");
     exec(ecmd->argv[0], ecmd->argv);
     fprintf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
@@ -164,8 +165,12 @@ main(void)
         fprintf(2, "cannot cd %s\n", buf+3);
       continue;
     }
+    //printf("shell before fork\n");
     if(fork1() == 0)
+    {
+      //printf("shell after fork before runcmd\n");
       runcmd(parsecmd(buf));
+    }
     wait(0);
   }
   exit(0);
@@ -196,7 +201,7 @@ struct cmd*
 execcmd(void)
 {
   struct execcmd *cmd;
-
+  //fprintf(2,"mallocing size of: %d\n",sizeof(*cmd));
   cmd = malloc(sizeof(*cmd));
   memset(cmd, 0, sizeof(*cmd));
   cmd->type = EXEC;
@@ -329,7 +334,6 @@ parsecmd(char *s)
 {
   char *es;
   struct cmd *cmd;
-
   es = s + strlen(s);
   cmd = parseline(&s, es);
   peek(&s, es, "");
@@ -345,7 +349,6 @@ struct cmd*
 parseline(char **ps, char *es)
 {
   struct cmd *cmd;
-
   cmd = parsepipe(ps, es);
   while(peek(ps, es, "&")){
     gettoken(ps, es, 0, 0);
@@ -362,7 +365,6 @@ struct cmd*
 parsepipe(char **ps, char *es)
 {
   struct cmd *cmd;
-
   cmd = parseexec(ps, es);
   if(peek(ps, es, "|")){
     gettoken(ps, es, 0, 0);
@@ -422,7 +424,6 @@ parseexec(char **ps, char *es)
 
   if(peek(ps, es, "("))
     return parseblock(ps, es);
-
   ret = execcmd();
   cmd = (struct execcmd*)ret;
 
diff --git a/user/sometests.c b/user/sometests.c
new file mode 100644
index 0000000..0c5162a
--- /dev/null
+++ b/user/sometests.c
@@ -0,0 +1,41 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+
+#define MAX_TOTAL_PAGES_USER 32
+
+int tst_MaxPages()
+{
+    int page_number = count_pages();
+    int child=fork();
+    char * ptrs[32];
+    if(child==0)
+    {
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number; i++)
+        {
+            ptrs[i]=sbrk(4096);
+            *ptrs[i]=i;
+        }
+
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number; i++)
+        {
+            if(*ptrs[i]==i)
+            {
+                printf("OK\n");
+            }
+        }
+        exit(0);
+    }
+    else
+    {
+        wait(&child);
+        printf("tst_MaxPagesInsideExecTest: OK\n");
+        return 0;
+    }
+    
+}
+
+int main(){
+    tst_MaxPages();
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/tomer.c b/user/tomer.c
new file mode 100644
index 0000000..7e00982
--- /dev/null
+++ b/user/tomer.c
@@ -0,0 +1,245 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+
+#define MAX_TOTAL_PAGES_USER 32
+
+int tst_MaxPages()
+{
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    fprintf(2,"Max pages test:\n");
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    int page_number = count_pages();
+    
+    int child=fork();
+    
+    char * ptrs[32];
+    if(child==0)
+    {
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number; i++)
+        {
+            ptrs[i]=sbrk(4096);
+            *ptrs[i]=i;
+        }
+
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number; i++)
+        {
+            if(*ptrs[i]==i)
+            {
+                printf("OK\n");
+            }
+        }
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER/2; i++)
+        {
+            if(i%2==0)
+            {
+                if(*ptrs[1]==i)
+                {
+                    printf("OK\n");
+                }
+            }
+            else
+            {
+                if(*ptrs[2]==i)
+                {
+                    printf("OK\n");
+                }
+            }
+        }
+        printf("ALL OK\n");
+        exit(0);
+    }
+    else
+    {
+        wait(&child);
+        fprintf(2,"Finish test\n");
+        fprintf(2,"--------------------------------------------------------------------------------\n");
+        return 0;
+    }
+    
+}
+
+
+int tst_TooManyPages()
+{
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    fprintf(2,"Too many pages test:\n");
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    int page_number = count_pages();
+    int child=fork();
+    char * ptrs[32];
+    if(child==0)
+    {
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number+1; i++)
+        {
+            ptrs[i]=sbrk(4096);
+            *ptrs[i]=i;
+        }
+
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number+1; i++)
+        {
+            if(*ptrs[i]==i)
+            {
+                printf("OK\n");
+            }
+        }
+        exit(0);
+    }
+    else
+    {
+        int ans=wait(&child);
+        if(ans<0)
+        {
+            printf("ALL OK\n");
+        }
+        else
+        {
+            printf("FAIL\n");
+        }
+        fprintf(2,"--------------------------------------------------------------------------------\n");
+        return 0;
+    }
+    
+}
+
+
+void tst_Exec()
+{
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    fprintf(2,"Exec test:\n");
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    int child=fork();
+    if(child==0)
+    {
+        //child
+        char *args[2] = { "sometests", 0 };
+        exec("/sometests", args);
+        printf("tst_Exec: FAIL\n");
+    }
+    else{
+        wait(&child);
+        printf("tst_Exec: OK\n");
+        fprintf(2,"--------------------------------------------------------------------------------\n");
+        return;
+    }
+}
+
+
+void tst_Fork()
+{
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    fprintf(2,"Fork test:\n");
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    char * ptrs[32];
+    int currentPages=count_pages();
+    for (int i = 0; i < MAX_TOTAL_PAGES_USER-currentPages; i++)
+    {
+        ptrs[i]=sbrk(4096);
+        *ptrs[i]=i;
+    }
+
+    int child=fork();
+    if(child==0)
+    {
+        int countFails=0;
+        //child
+        for (int i = 0; i < MAX_TOTAL_PAGES_USER-currentPages; i++)
+        {
+            if(*ptrs[i]==i)
+            {
+                printf("OK\n");
+            }
+            else{
+                printf("FAIL\n");
+                countFails++;
+            }
+        }
+
+        if(countFails==0)
+        {
+            printf("Fork test: ALL PASS\n");
+        }
+        else
+        {
+            printf("Fork test:FAIL\n");
+        }
+        exit(0);
+    }
+    else{
+        //father
+        wait(&child);
+        fprintf(2,"--------------------------------------------------------------------------------\n");
+        return;
+    }
+
+}
+
+void tst_Pagefaults(){
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    fprintf(2,"Pagefaults test:\n");
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    int page_number = count_pages();
+    char * ptrs[32];
+
+    int countWithoutPageFaults=0;
+    fprintf(2,"Creations: add pages to proc: --------------\n");
+    for (int i = 0; i < MAX_TOTAL_PAGES_USER/2-page_number; i++)
+    {
+        ptrs[i]=sbrk(4096);
+        int wasPagefault = pagefault();
+        if(wasPagefault)
+        {
+            printf("FAIL\n");
+        }
+        else
+        {
+            countWithoutPageFaults++;
+            printf("Ok\n");
+        }
+
+    }
+    fprintf(2, "%d pages was created with %d pagefaults\n",MAX_TOTAL_PAGES_USER/2-page_number,MAX_TOTAL_PAGES_USER/2-page_number-countWithoutPageFaults);
+    int countPageFaults=0;
+    for (int i =  MAX_TOTAL_PAGES_USER/2-page_number; i < MAX_TOTAL_PAGES_USER/2; i++)
+    {
+        ptrs[i]=sbrk(4096);
+        int wasPagefault = pagefault();
+        if(wasPagefault)
+        {
+            countPageFaults++;
+        }
+    }
+    fprintf(2,"%d pages was created with %d pagefaults\n",MAX_TOTAL_PAGES_USER/2, countPageFaults);
+
+    fprintf(2,"Access to memeory:-----------------\n");
+    countPageFaults=0;
+    for (int i = 0; i < MAX_TOTAL_PAGES_USER-page_number; i++)
+    {
+        *ptrs[i]=5;
+        int wasPagefault = pagefault();
+        if(wasPagefault)
+        {
+            countPageFaults++;
+        }
+    }
+    fprintf(2,"%d accesses to pages went with %d pagefaults\n",MAX_TOTAL_PAGES_USER/2, countPageFaults);
+    fprintf(2,"--------------------------------------------------------------------------------\n");
+    return;
+}
+
+int main(){
+
+    //basic tsts
+    tst_Pagefaults();
+
+    //max tsts
+    tst_MaxPages();
+    //tst_TooManyPages();   
+
+
+    //fork and exec
+    tst_Exec();
+    tst_Fork();
+    
+    exit(0);
+}
diff --git a/user/user.h b/user/user.h
index b71ecda..bff7647 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,6 +23,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int count_pages(void);
+int pagefault(void);
+int flipPageTracePrintFlag(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usertests.c b/user/usertests.c
index ba4255b..11434aa 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -17,2644 +17,2645 @@
 // prints "OK".
 //
 
-#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
+//#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
+#define BUFSZ  ((2+2)*BSIZE)
 
 char buf[BUFSZ];
 
 // what if you pass ridiculous pointers to system calls
 // that read user memory with copyin?
-void
-copyin(char *s)
-{
-  uint64 addrs[] = { 0x80000000LL, 0xffffffffffffffff };
+// void
+// copyin(char *s)
+// {
+//   uint64 addrs[] = { 0x80000000LL, 0xffffffffffffffff };
 
-  for(int ai = 0; ai < 2; ai++){
-    uint64 addr = addrs[ai];
+//   for(int ai = 0; ai < 2; ai++){
+//     uint64 addr = addrs[ai];
     
-    int fd = open("copyin1", O_CREATE|O_WRONLY);
-    if(fd < 0){
-      printf("open(copyin1) failed\n");
-      exit(1);
-    }
-    int n = write(fd, (void*)addr, 8192);
-    if(n >= 0){
-      printf("write(fd, %p, 8192) returned %d, not -1\n", addr, n);
-      exit(1);
-    }
-    close(fd);
-    unlink("copyin1");
+//     int fd = open("copyin1", O_CREATE|O_WRONLY);
+//     if(fd < 0){
+//       printf("open(copyin1) failed\n");
+//       exit(1);
+//     }
+//     int n = write(fd, (void*)addr, 8192);
+//     if(n >= 0){
+//       printf("write(fd, %p, 8192) returned %d, not -1\n", addr, n);
+//       exit(1);
+//     }
+//     close(fd);
+//     unlink("copyin1");
     
-    n = write(1, (char*)addr, 8192);
-    if(n > 0){
-      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", addr, n);
-      exit(1);
-    }
+//     n = write(1, (char*)addr, 8192);
+//     if(n > 0){
+//       printf("write(1, %p, 8192) returned %d, not -1 or 0\n", addr, n);
+//       exit(1);
+//     }
     
-    int fds[2];
-    if(pipe(fds) < 0){
-      printf("pipe() failed\n");
-      exit(1);
-    }
-    n = write(fds[1], (char*)addr, 8192);
-    if(n > 0){
-      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", addr, n);
-      exit(1);
-    }
-    close(fds[0]);
-    close(fds[1]);
-  }
-}
-
-// what if you pass ridiculous pointers to system calls
-// that write user memory with copyout?
-void
-copyout(char *s)
-{
-  uint64 addrs[] = { 0x80000000LL, 0xffffffffffffffff };
-
-  for(int ai = 0; ai < 2; ai++){
-    uint64 addr = addrs[ai];
-
-    int fd = open("README", 0);
-    if(fd < 0){
-      printf("open(README) failed\n");
-      exit(1);
-    }
-    int n = read(fd, (void*)addr, 8192);
-    if(n > 0){
-      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", addr, n);
-      exit(1);
-    }
-    close(fd);
-
-    int fds[2];
-    if(pipe(fds) < 0){
-      printf("pipe() failed\n");
-      exit(1);
-    }
-    n = write(fds[1], "x", 1);
-    if(n != 1){
-      printf("pipe write failed\n");
-      exit(1);
-    }
-    n = read(fds[0], (void*)addr, 8192);
-    if(n > 0){
-      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", addr, n);
-      exit(1);
-    }
-    close(fds[0]);
-    close(fds[1]);
-  }
-}
-
-// what if you pass ridiculous string pointers to system calls?
-void
-copyinstr1(char *s)
-{
-  uint64 addrs[] = { 0x80000000LL, 0xffffffffffffffff };
-
-  for(int ai = 0; ai < 2; ai++){
-    uint64 addr = addrs[ai];
-
-    int fd = open((char *)addr, O_CREATE|O_WRONLY);
-    if(fd >= 0){
-      printf("open(%p) returned %d, not -1\n", addr, fd);
-      exit(1);
-    }
-  }
-}
-
-// what if a string system call argument is exactly the size
-// of the kernel buffer it is copied into, so that the null
-// would fall just beyond the end of the kernel buffer?
-void
-copyinstr2(char *s)
-{
-  char b[MAXPATH+1];
-
-  for(int i = 0; i < MAXPATH; i++)
-    b[i] = 'x';
-  b[MAXPATH] = '\0';
+//     int fds[2];
+//     if(pipe(fds) < 0){
+//       printf("pipe() failed\n");
+//       exit(1);
+//     }
+//     n = write(fds[1], (char*)addr, 8192);
+//     if(n > 0){
+//       printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", addr, n);
+//       exit(1);
+//     }
+//     close(fds[0]);
+//     close(fds[1]);
+//   }
+// }
+
+// // what if you pass ridiculous pointers to system calls
+// // that write user memory with copyout?
+// void
+// copyout(char *s)
+// {
+//   uint64 addrs[] = { 0x80000000LL, 0xffffffffffffffff };
+
+//   for(int ai = 0; ai < 2; ai++){
+//     uint64 addr = addrs[ai];
+
+//     int fd = open("README", 0);
+//     if(fd < 0){
+//       printf("open(README) failed\n");
+//       exit(1);
+//     }
+//     int n = read(fd, (void*)addr, 8192);
+//     if(n > 0){
+//       printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", addr, n);
+//       exit(1);
+//     }
+//     close(fd);
+
+//     int fds[2];
+//     if(pipe(fds) < 0){
+//       printf("pipe() failed\n");
+//       exit(1);
+//     }
+//     n = write(fds[1], "x", 1);
+//     if(n != 1){
+//       printf("pipe write failed\n");
+//       exit(1);
+//     }
+//     n = read(fds[0], (void*)addr, 8192);
+//     if(n > 0){
+//       printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", addr, n);
+//       exit(1);
+//     }
+//     close(fds[0]);
+//     close(fds[1]);
+//   }
+// }
+
+// // what if you pass ridiculous string pointers to system calls?
+// void
+// copyinstr1(char *s)
+// {
+//   uint64 addrs[] = { 0x80000000LL, 0xffffffffffffffff };
+
+//   for(int ai = 0; ai < 2; ai++){
+//     uint64 addr = addrs[ai];
+
+//     int fd = open((char *)addr, O_CREATE|O_WRONLY);
+//     if(fd >= 0){
+//       printf("open(%p) returned %d, not -1\n", addr, fd);
+//       exit(1);
+//     }
+//   }
+// }
+
+// // what if a string system call argument is exactly the size
+// // of the kernel buffer it is copied into, so that the null
+// // would fall just beyond the end of the kernel buffer?
+// void
+// copyinstr2(char *s)
+// {
+//   char b[MAXPATH+1];
+
+//   for(int i = 0; i < MAXPATH; i++)
+//     b[i] = 'x';
+//   b[MAXPATH] = '\0';
   
-  int ret = unlink(b);
-  if(ret != -1){
-    printf("unlink(%s) returned %d, not -1\n", b, ret);
-    exit(1);
-  }
-
-  int fd = open(b, O_CREATE | O_WRONLY);
-  if(fd != -1){
-    printf("open(%s) returned %d, not -1\n", b, fd);
-    exit(1);
-  }
-
-  ret = link(b, b);
-  if(ret != -1){
-    printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
-    exit(1);
-  }
-
-  char *args[] = { "xx", 0 };
-  ret = exec(b, args);
-  if(ret != -1){
-    printf("exec(%s) returned %d, not -1\n", b, fd);
-    exit(1);
-  }
-
-  int pid = fork();
-  if(pid < 0){
-    printf("fork failed\n");
-    exit(1);
-  }
-  if(pid == 0){
-    static char big[PGSIZE+1];
-    for(int i = 0; i < PGSIZE; i++)
-      big[i] = 'x';
-    big[PGSIZE] = '\0';
-    char *args2[] = { big, big, big, 0 };
-    ret = exec("echo", args2);
-    if(ret != -1){
-      printf("exec(echo, BIG) returned %d, not -1\n", fd);
-      exit(1);
-    }
-    exit(747); // OK
-  }
-
-  int st = 0;
-  wait(&st);
-  if(st != 747){
-    printf("exec(echo, BIG) succeeded, should have failed\n");
-    exit(1);
-  }
-}
-
-// what if a string argument crosses over the end of last user page?
-void
-copyinstr3(char *s)
-{
-  sbrk(8192);
-  uint64 top = (uint64) sbrk(0);
-  if((top % PGSIZE) != 0){
-    sbrk(PGSIZE - (top % PGSIZE));
-  }
-  top = (uint64) sbrk(0);
-  if(top % PGSIZE){
-    printf("oops\n");
-    exit(1);
-  }
-
-  char *b = (char *) (top - 1);
-  *b = 'x';
-
-  int ret = unlink(b);
-  if(ret != -1){
-    printf("unlink(%s) returned %d, not -1\n", b, ret);
-    exit(1);
-  }
-
-  int fd = open(b, O_CREATE | O_WRONLY);
-  if(fd != -1){
-    printf("open(%s) returned %d, not -1\n", b, fd);
-    exit(1);
-  }
-
-  ret = link(b, b);
-  if(ret != -1){
-    printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
-    exit(1);
-  }
-
-  char *args[] = { "xx", 0 };
-  ret = exec(b, args);
-  if(ret != -1){
-    printf("exec(%s) returned %d, not -1\n", b, fd);
-    exit(1);
-  }
-}
-
-// See if the kernel refuses to read/write user memory that the
-// application doesn't have anymore, because it returned it.
-void
-rwsbrk()
-{
-  int fd, n;
+//   int ret = unlink(b);
+//   if(ret != -1){
+//     printf("unlink(%s) returned %d, not -1\n", b, ret);
+//     exit(1);
+//   }
+
+//   int fd = open(b, O_CREATE | O_WRONLY);
+//   if(fd != -1){
+//     printf("open(%s) returned %d, not -1\n", b, fd);
+//     exit(1);
+//   }
+
+//   ret = link(b, b);
+//   if(ret != -1){
+//     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+//     exit(1);
+//   }
+
+//   char *args[] = { "xx", 0 };
+//   ret = exec(b, args);
+//   if(ret != -1){
+//     printf("exec(%s) returned %d, not -1\n", b, fd);
+//     exit(1);
+//   }
+
+//   int pid = fork();
+//   if(pid < 0){
+//     printf("fork failed\n");
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     static char big[PGSIZE+1];
+//     for(int i = 0; i < PGSIZE; i++)
+//       big[i] = 'x';
+//     big[PGSIZE] = '\0';
+//     char *args2[] = { big, big, big, 0 };
+//     ret = exec("echo", args2);
+//     if(ret != -1){
+//       printf("exec(echo, BIG) returned %d, not -1\n", fd);
+//       exit(1);
+//     }
+//     exit(747); // OK
+//   }
+
+//   int st = 0;
+//   wait(&st);
+//   if(st != 747){
+//     printf("exec(echo, BIG) succeeded, should have failed\n");
+//     exit(1);
+//   }
+// }
+
+// // what if a string argument crosses over the end of last user page?
+// void
+// copyinstr3(char *s)
+// {
+//   sbrk(8192);
+//   uint64 top = (uint64) sbrk(0);
+//   if((top % PGSIZE) != 0){
+//     sbrk(PGSIZE - (top % PGSIZE));
+//   }
+//   top = (uint64) sbrk(0);
+//   if(top % PGSIZE){
+//     printf("oops\n");
+//     exit(1);
+//   }
+
+//   char *b = (char *) (top - 1);
+//   *b = 'x';
+
+//   int ret = unlink(b);
+//   if(ret != -1){
+//     printf("unlink(%s) returned %d, not -1\n", b, ret);
+//     exit(1);
+//   }
+
+//   int fd = open(b, O_CREATE | O_WRONLY);
+//   if(fd != -1){
+//     printf("open(%s) returned %d, not -1\n", b, fd);
+//     exit(1);
+//   }
+
+//   ret = link(b, b);
+//   if(ret != -1){
+//     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+//     exit(1);
+//   }
+
+//   char *args[] = { "xx", 0 };
+//   ret = exec(b, args);
+//   if(ret != -1){
+//     printf("exec(%s) returned %d, not -1\n", b, fd);
+//     exit(1);
+//   }
+// }
+
+// // See if the kernel refuses to read/write user memory that the
+// // application doesn't have anymore, because it returned it.
+// void
+// rwsbrk()
+// {
+//   int fd, n;
   
-  uint64 a = (uint64) sbrk(8192);
+//   uint64 a = (uint64) sbrk(8192);
 
-  if(a == 0xffffffffffffffffLL) {
-    printf("sbrk(rwsbrk) failed\n");
-    exit(1);
-  }
+//   if(a == 0xffffffffffffffffLL) {
+//     printf("sbrk(rwsbrk) failed\n");
+//     exit(1);
+//   }
   
-  if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
-    printf("sbrk(rwsbrk) shrink failed\n");
-    exit(1);
-  }
-
-  fd = open("rwsbrk", O_CREATE|O_WRONLY);
-  if(fd < 0){
-    printf("open(rwsbrk) failed\n");
-    exit(1);
-  }
-  n = write(fd, (void*)(a+4096), 1024);
-  if(n >= 0){
-    printf("write(fd, %p, 1024) returned %d, not -1\n", a+4096, n);
-    exit(1);
-  }
-  close(fd);
-  unlink("rwsbrk");
-
-  fd = open("README", O_RDONLY);
-  if(fd < 0){
-    printf("open(rwsbrk) failed\n");
-    exit(1);
-  }
-  n = read(fd, (void*)(a+4096), 10);
-  if(n >= 0){
-    printf("read(fd, %p, 10) returned %d, not -1\n", a+4096, n);
-    exit(1);
-  }
-  close(fd);
+//   if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
+//     printf("sbrk(rwsbrk) shrink failed\n");
+//     exit(1);
+//   }
+
+//   fd = open("rwsbrk", O_CREATE|O_WRONLY);
+//   if(fd < 0){
+//     printf("open(rwsbrk) failed\n");
+//     exit(1);
+//   }
+//   n = write(fd, (void*)(a+4096), 1024);
+//   if(n >= 0){
+//     printf("write(fd, %p, 1024) returned %d, not -1\n", a+4096, n);
+//     exit(1);
+//   }
+//   close(fd);
+//   unlink("rwsbrk");
+
+//   fd = open("README", O_RDONLY);
+//   if(fd < 0){
+//     printf("open(rwsbrk) failed\n");
+//     exit(1);
+//   }
+//   n = read(fd, (void*)(a+4096), 10);
+//   if(n >= 0){
+//     printf("read(fd, %p, 10) returned %d, not -1\n", a+4096, n);
+//     exit(1);
+//   }
+//   close(fd);
   
-  exit(0);
-}
-
-// test O_TRUNC.
-void
-truncate1(char *s)
-{
-  char buf[32];
+//   exit(0);
+// }
+
+// // test O_TRUNC.
+// void
+// truncate1(char *s)
+// {
+//   char buf[32];
   
-  unlink("truncfile");
-  int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
-  write(fd1, "abcd", 4);
-  close(fd1);
-
-  int fd2 = open("truncfile", O_RDONLY);
-  int n = read(fd2, buf, sizeof(buf));
-  if(n != 4){
-    printf("%s: read %d bytes, wanted 4\n", s, n);
-    exit(1);
-  }
-
-  fd1 = open("truncfile", O_WRONLY|O_TRUNC);
-
-  int fd3 = open("truncfile", O_RDONLY);
-  n = read(fd3, buf, sizeof(buf));
-  if(n != 0){
-    printf("aaa fd3=%d\n", fd3);
-    printf("%s: read %d bytes, wanted 0\n", s, n);
-    exit(1);
-  }
-
-  n = read(fd2, buf, sizeof(buf));
-  if(n != 0){
-    printf("bbb fd2=%d\n", fd2);
-    printf("%s: read %d bytes, wanted 0\n", s, n);
-    exit(1);
-  }
+//   unlink("truncfile");
+//   int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+//   write(fd1, "abcd", 4);
+//   close(fd1);
+
+//   int fd2 = open("truncfile", O_RDONLY);
+//   int n = read(fd2, buf, sizeof(buf));
+//   if(n != 4){
+//     printf("%s: read %d bytes, wanted 4\n", s, n);
+//     exit(1);
+//   }
+
+//   fd1 = open("truncfile", O_WRONLY|O_TRUNC);
+
+//   int fd3 = open("truncfile", O_RDONLY);
+//   n = read(fd3, buf, sizeof(buf));
+//   if(n != 0){
+//     printf("aaa fd3=%d\n", fd3);
+//     printf("%s: read %d bytes, wanted 0\n", s, n);
+//     exit(1);
+//   }
+
+//   n = read(fd2, buf, sizeof(buf));
+//   if(n != 0){
+//     printf("bbb fd2=%d\n", fd2);
+//     printf("%s: read %d bytes, wanted 0\n", s, n);
+//     exit(1);
+//   }
   
-  write(fd1, "abcdef", 6);
-
-  n = read(fd3, buf, sizeof(buf));
-  if(n != 6){
-    printf("%s: read %d bytes, wanted 6\n", s, n);
-    exit(1);
-  }
-
-  n = read(fd2, buf, sizeof(buf));
-  if(n != 2){
-    printf("%s: read %d bytes, wanted 2\n", s, n);
-    exit(1);
-  }
-
-  unlink("truncfile");
-
-  close(fd1);
-  close(fd2);
-  close(fd3);
-}
-
-// write to an open FD whose file has just been truncated.
-// this causes a write at an offset beyond the end of the file.
-// such writes fail on xv6 (unlike POSIX) but at least
-// they don't crash.
-void
-truncate2(char *s)
-{
-  unlink("truncfile");
-
-  int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
-  write(fd1, "abcd", 4);
-
-  int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
-
-  int n = write(fd1, "x", 1);
-  if(n != -1){
-    printf("%s: write returned %d, expected -1\n", s, n);
-    exit(1);
-  }
-
-  unlink("truncfile");
-  close(fd1);
-  close(fd2);
-}
-
-void
-truncate3(char *s)
-{
-  int pid, xstatus;
-
-  close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
+//   write(fd1, "abcdef", 6);
+
+//   n = read(fd3, buf, sizeof(buf));
+//   if(n != 6){
+//     printf("%s: read %d bytes, wanted 6\n", s, n);
+//     exit(1);
+//   }
+
+//   n = read(fd2, buf, sizeof(buf));
+//   if(n != 2){
+//     printf("%s: read %d bytes, wanted 2\n", s, n);
+//     exit(1);
+//   }
+
+//   unlink("truncfile");
+
+//   close(fd1);
+//   close(fd2);
+//   close(fd3);
+// }
+
+// // write to an open FD whose file has just been truncated.
+// // this causes a write at an offset beyond the end of the file.
+// // such writes fail on xv6 (unlike POSIX) but at least
+// // they don't crash.
+// void
+// truncate2(char *s)
+// {
+//   unlink("truncfile");
+
+//   int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
+//   write(fd1, "abcd", 4);
+
+//   int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
+
+//   int n = write(fd1, "x", 1);
+//   if(n != -1){
+//     printf("%s: write returned %d, expected -1\n", s, n);
+//     exit(1);
+//   }
+
+//   unlink("truncfile");
+//   close(fd1);
+//   close(fd2);
+// }
+
+// void
+// truncate3(char *s)
+// {
+//   int pid, xstatus;
+
+//   close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
   
-  pid = fork();
-  if(pid < 0){
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-
-  if(pid == 0){
-    for(int i = 0; i < 100; i++){
-      char buf[32];
-      int fd = open("truncfile", O_WRONLY);
-      if(fd < 0){
-        printf("%s: open failed\n", s);
-        exit(1);
-      }
-      int n = write(fd, "1234567890", 10);
-      if(n != 10){
-        printf("%s: write got %d, expected 10\n", s, n);
-        exit(1);
-      }
-      close(fd);
-      fd = open("truncfile", O_RDONLY);
-      read(fd, buf, sizeof(buf));
-      close(fd);
-    }
-    exit(0);
-  }
-
-  for(int i = 0; i < 150; i++){
-    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
-    if(fd < 0){
-      printf("%s: open failed\n", s);
-      exit(1);
-    }
-    int n = write(fd, "xxx", 3);
-    if(n != 3){
-      printf("%s: write got %d, expected 3\n", s, n);
-      exit(1);
-    }
-    close(fd);
-  }
-
-  wait(&xstatus);
-  unlink("truncfile");
-  exit(xstatus);
-}
+//   pid = fork();
+//   if(pid < 0){
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+
+//   if(pid == 0){
+//     for(int i = 0; i < 100; i++){
+//       char buf[32];
+//       int fd = open("truncfile", O_WRONLY);
+//       if(fd < 0){
+//         printf("%s: open failed\n", s);
+//         exit(1);
+//       }
+//       int n = write(fd, "1234567890", 10);
+//       if(n != 10){
+//         printf("%s: write got %d, expected 10\n", s, n);
+//         exit(1);
+//       }
+//       close(fd);
+//       fd = open("truncfile", O_RDONLY);
+//       read(fd, buf, sizeof(buf));
+//       close(fd);
+//     }
+//     exit(0);
+//   }
+
+//   for(int i = 0; i < 150; i++){
+//     int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+//     if(fd < 0){
+//       printf("%s: open failed\n", s);
+//       exit(1);
+//     }
+//     int n = write(fd, "xxx", 3);
+//     if(n != 3){
+//       printf("%s: write got %d, expected 3\n", s, n);
+//       exit(1);
+//     }
+//     close(fd);
+//   }
+
+//   wait(&xstatus);
+//   unlink("truncfile");
+//   exit(xstatus);
+// }
   
 
-// does chdir() call iput(p->cwd) in a transaction?
-void
-iputtest(char *s)
-{
-  if(mkdir("iputdir") < 0){
-    printf("%s: mkdir failed\n", s);
-    exit(1);
-  }
-  if(chdir("iputdir") < 0){
-    printf("%s: chdir iputdir failed\n", s);
-    exit(1);
-  }
-  if(unlink("../iputdir") < 0){
-    printf("%s: unlink ../iputdir failed\n", s);
-    exit(1);
-  }
-  if(chdir("/") < 0){
-    printf("%s: chdir / failed\n", s);
-    exit(1);
-  }
-}
+// // does chdir() call iput(p->cwd) in a transaction?
+// void
+// iputtest(char *s)
+// {
+//   if(mkdir("iputdir") < 0){
+//     printf("%s: mkdir failed\n", s);
+//     exit(1);
+//   }
+//   if(chdir("iputdir") < 0){
+//     printf("%s: chdir iputdir failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink("../iputdir") < 0){
+//     printf("%s: unlink ../iputdir failed\n", s);
+//     exit(1);
+//   }
+//   if(chdir("/") < 0){
+//     printf("%s: chdir / failed\n", s);
+//     exit(1);
+//   }
+// }
+
+// // does exit() call iput(p->cwd) in a transaction?
+// void
+// exitiputtest(char *s)
+// {
+//   int pid, xstatus;
+
+//   pid = fork();
+//   if(pid < 0){
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     if(mkdir("iputdir") < 0){
+//       printf("%s: mkdir failed\n", s);
+//       exit(1);
+//     }
+//     if(chdir("iputdir") < 0){
+//       printf("%s: child chdir failed\n", s);
+//       exit(1);
+//     }
+//     if(unlink("../iputdir") < 0){
+//       printf("%s: unlink ../iputdir failed\n", s);
+//       exit(1);
+//     }
+//     exit(0);
+//   }
+//   wait(&xstatus);
+//   exit(xstatus);
+// }
+
+// // does the error path in open() for attempt to write a
+// // directory call iput() in a transaction?
+// // needs a hacked kernel that pauses just after the namei()
+// // call in sys_open():
+// //    if((ip = namei(path)) == 0)
+// //      return -1;
+// //    {
+// //      int i;
+// //      for(i = 0; i < 10000; i++)
+// //        yield();
+// //    }
+// void
+// openiputtest(char *s)
+// {
+//   int pid, xstatus;
+
+//   if(mkdir("oidir") < 0){
+//     printf("%s: mkdir oidir failed\n", s);
+//     exit(1);
+//   }
+//   pid = fork();
+//   if(pid < 0){
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     int fd = open("oidir", O_RDWR);
+//     if(fd >= 0){
+//       printf("%s: open directory for write succeeded\n", s);
+//       exit(1);
+//     }
+//     exit(0);
+//   }
+//   sleep(1);
+//   if(unlink("oidir") != 0){
+//     printf("%s: unlink failed\n", s);
+//     exit(1);
+//   }
+//   wait(&xstatus);
+//   exit(xstatus);
+// }
+
+// // simple file system tests
+
+// void
+// opentest(char *s)
+// {
+//   int fd;
+
+//   fd = open("echo", 0);
+//   if(fd < 0){
+//     printf("%s: open echo failed!\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+//   fd = open("doesnotexist", 0);
+//   if(fd >= 0){
+//     printf("%s: open doesnotexist succeeded!\n", s);
+//     exit(1);
+//   }
+// }
+
+// void
+// writetest(char *s)
+// {
+//   int fd;
+//   int i;
+//   enum { N=100, SZ=10 };
+  
+//   fd = open("small", O_CREATE|O_RDWR);
+//   if(fd < 0){
+//     printf("%s: error: creat small failed!\n", s);
+//     exit(1);
+//   }
+//   for(i = 0; i < N; i++){
+//     if(write(fd, "aaaaaaaaaa", SZ) != SZ){
+//       printf("%s: error: write aa %d new file failed\n", s, i);
+//       exit(1);
+//     }
+//     if(write(fd, "bbbbbbbbbb", SZ) != SZ){
+//       printf("%s: error: write bb %d new file failed\n", s, i);
+//       exit(1);
+//     }
+//   }
+//   close(fd);
+//   fd = open("small", O_RDONLY);
+//   if(fd < 0){
+//     printf("%s: error: open small failed!\n", s);
+//     exit(1);
+//   }
+//   i = read(fd, buf, N*SZ*2);
+//   if(i != N*SZ*2){
+//     printf("%s: read failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   if(unlink("small") < 0){
+//     printf("%s: unlink small failed\n", s);
+//     exit(1);
+//   }
+// }
+
+// void
+// writebig(char *s)
+// {
+//   int i, fd, n;
+
+//   fd = open("big", O_CREATE|O_RDWR);
+//   if(fd < 0){
+//     printf("%s: error: creat big failed!\n", s);
+//     exit(1);
+//   }
+
+//   for(i = 0; i < MAXFILE; i++){
+//     ((int*)buf)[0] = i;
+//     if(write(fd, buf, BSIZE) != BSIZE){
+//       printf("%s: error: write big file failed\n", s, i);
+//       exit(1);
+//     }
+//   }
+
+//   close(fd);
+
+//   fd = open("big", O_RDONLY);
+//   if(fd < 0){
+//     printf("%s: error: open big failed!\n", s);
+//     exit(1);
+//   }
+
+//   n = 0;
+//   for(;;){
+//     i = read(fd, buf, BSIZE);
+//     if(i == 0){
+//       if(n == MAXFILE - 1){
+//         printf("%s: read only %d blocks from big", s, n);
+//         exit(1);
+//       }
+//       break;
+//     } else if(i != BSIZE){
+//       printf("%s: read failed %d\n", s, i);
+//       exit(1);
+//     }
+//     if(((int*)buf)[0] != n){
+//       printf("%s: read content of block %d is %d\n", s,
+//              n, ((int*)buf)[0]);
+//       exit(1);
+//     }
+//     n++;
+//   }
+//   close(fd);
+//   if(unlink("big") < 0){
+//     printf("%s: unlink big failed\n", s);
+//     exit(1);
+//   }
+// }
+
+// // many creates, followed by unlink test
+// void
+// createtest(char *s)
+// {
+//   int i, fd;
+//   enum { N=52 };
+
+//   char name[3];
+//   name[0] = 'a';
+//   name[2] = '\0';
+//   for(i = 0; i < N; i++){
+//     name[1] = '0' + i;
+//     fd = open(name, O_CREATE|O_RDWR);
+//     close(fd);
+//   }
+//   name[0] = 'a';
+//   name[2] = '\0';
+//   for(i = 0; i < N; i++){
+//     name[1] = '0' + i;
+//     unlink(name);
+//   }
+// }
+
+// void dirtest(char *s)
+// {
+//   if(mkdir("dir0") < 0){
+//     printf("%s: mkdir failed\n", s);
+//     exit(1);
+//   }
+
+//   if(chdir("dir0") < 0){
+//     printf("%s: chdir dir0 failed\n", s);
+//     exit(1);
+//   }
+
+//   if(chdir("..") < 0){
+//     printf("%s: chdir .. failed\n", s);
+//     exit(1);
+//   }
+
+//   if(unlink("dir0") < 0){
+//     printf("%s: unlink dir0 failed\n", s);
+//     exit(1);
+//   }
+// }
+
+// void
+// exectest(char *s)
+// {
+//   int fd, xstatus, pid;
+//   char *echoargv[] = { "echo", "OK", 0 };
+//   char buf[3];
+
+//   unlink("echo-ok");
+//   pid = fork();
+//   if(pid < 0) {
+//      printf("%s: fork failed\n", s);
+//      exit(1);
+//   }
+//   if(pid == 0) {
+//     close(1);
+//     fd = open("echo-ok", O_CREATE|O_WRONLY);
+//     if(fd < 0) {
+//       printf("%s: create failed\n", s);
+//       exit(1);
+//     }
+//     if(fd != 1) {
+//       printf("%s: wrong fd\n", s);
+//       exit(1);
+//     }
+//     if(exec("echo", echoargv) < 0){
+//       printf("%s: exec echo failed\n", s);
+//       exit(1);
+//     }
+//     // won't get to here
+//   }
+//   if (wait(&xstatus) != pid) {
+//     printf("%s: wait failed!\n", s);
+//   }
+//   if(xstatus != 0)
+//     exit(xstatus);
+
+//   fd = open("echo-ok", O_RDONLY);
+//   if(fd < 0) {
+//     printf("%s: open failed\n", s);
+//     exit(1);
+//   }
+//   if (read(fd, buf, 2) != 2) {
+//     printf("%s: read failed\n", s);
+//     exit(1);
+//   }
+//   unlink("echo-ok");
+//   if(buf[0] == 'O' && buf[1] == 'K')
+//     exit(0);
+//   else {
+//     printf("%s: wrong output\n", s);
+//     exit(1);
+//   }
+
+// }
+
+// // simple fork and pipe read/write
+
+// void
+// pipe1(char *s)
+// {
+//   int fds[2], pid, xstatus;
+//   int seq, i, n, cc, total;
+//   enum { N=5, SZ=1033 };
+  
+//   if(pipe(fds) != 0){
+//     printf("%s: pipe() failed\n", s);
+//     exit(1);
+//   }
+//   pid = fork();
+//   seq = 0;
+//   if(pid == 0){
+//     close(fds[0]);
+//     for(n = 0; n < N; n++){
+//       for(i = 0; i < SZ; i++)
+//         buf[i] = seq++;
+//       if(write(fds[1], buf, SZ) != SZ){
+//         printf("%s: pipe1 oops 1\n", s);
+//         exit(1);
+//       }
+//     }
+//     exit(0);
+//   } else if(pid > 0){
+//     close(fds[1]);
+//     total = 0;
+//     cc = 1;
+//     while((n = read(fds[0], buf, cc)) > 0){
+//       for(i = 0; i < n; i++){
+//         if((buf[i] & 0xff) != (seq++ & 0xff)){
+//           printf("%s: pipe1 oops 2\n", s);
+//           return;
+//         }
+//       }
+//       total += n;
+//       cc = cc * 2;
+//       if(cc > sizeof(buf))
+//         cc = sizeof(buf);
+//     }
+//     if(total != N * SZ){
+//       printf("%s: pipe1 oops 3 total %d\n", total);
+//       exit(1);
+//     }
+//     close(fds[0]);
+//     wait(&xstatus);
+//     exit(xstatus);
+//   } else {
+//     printf("%s: fork() failed\n", s);
+//     exit(1);
+//   }
+// }
+
+
+// // test if child is killed (status = -1)
+// void
+// killstatus(char *s)
+// {
+//   int xst;
+  
+//   for(int i = 0; i < 100; i++){
+//     int pid1 = fork();
+//     if(pid1 < 0){
+//       printf("%s: fork failed\n", s);
+//       exit(1);
+//     }
+//     if(pid1 == 0){
+//       while(1) {
+//         getpid();
+//       }
+//       exit(0);
+//     }
+//     sleep(1);
+//     kill(pid1);
+//     wait(&xst);
+//     if(xst != -1) {
+//        printf("%s: status should be -1\n", s);
+//        exit(1);
+//     }
+//   }
+//   exit(0);
+// }
+
+// // meant to be run w/ at most two CPUs
+// void
+// preempt(char *s)
+// {
+//   int pid1, pid2, pid3;
+//   int pfds[2];
+
+//   pid1 = fork();
+//   if(pid1 < 0) {
+//     printf("%s: fork failed", s);
+//     exit(1);
+//   }
+//   if(pid1 == 0)
+//     for(;;)
+//       ;
+
+//   pid2 = fork();
+//   if(pid2 < 0) {
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+//   if(pid2 == 0)
+//     for(;;)
+//       ;
+
+//   pipe(pfds);
+//   pid3 = fork();
+//   if(pid3 < 0) {
+//      printf("%s: fork failed\n", s);
+//      exit(1);
+//   }
+//   if(pid3 == 0){
+//     close(pfds[0]);
+//     if(write(pfds[1], "x", 1) != 1)
+//       printf("%s: preempt write error", s);
+//     close(pfds[1]);
+//     for(;;)
+//       ;
+//   }
+
+//   close(pfds[1]);
+//   if(read(pfds[0], buf, sizeof(buf)) != 1){
+//     printf("%s: preempt read error", s);
+//     return;
+//   }
+//   close(pfds[0]);
+//   printf("kill... ");
+//   kill(pid1);
+//   kill(pid2);
+//   kill(pid3);
+//   printf("wait... ");
+//   wait(0);
+//   wait(0);
+//   wait(0);
+// }
+
+// // try to find any races between exit and wait
+// void
+// exitwait(char *s)
+// {
+//   int i, pid;
+
+//   for(i = 0; i < 100; i++){
+//     pid = fork();
+//     if(pid < 0){
+//       printf("%s: fork failed\n", s);
+//       exit(1);
+//     }
+//     if(pid){
+//       int xstate;
+//       if(wait(&xstate) != pid){
+//         printf("%s: wait wrong pid\n", s);
+//         exit(1);
+//       }
+//       if(i != xstate) {
+//         printf("%s: wait wrong exit status\n", s);
+//         exit(1);
+//       }
+//     } else {
+//       exit(i);
+//     }
+//   }
+// }
+
+// // try to find races in the reparenting
+// // code that handles a parent exiting
+// // when it still has live children.
+// void
+// reparent(char *s)
+// {
+//   int master_pid = getpid();
+//   for(int i = 0; i < 200; i++){
+//     int pid = fork();
+//     if(pid < 0){
+//       printf("%s: fork failed\n", s);
+//       exit(1);
+//     }
+//     if(pid){
+//       if(wait(0) != pid){
+//         printf("%s: wait wrong pid\n", s);
+//         exit(1);
+//       }
+//     } else {
+//       int pid2 = fork();
+//       if(pid2 < 0){
+//         kill(master_pid);
+//         exit(1);
+//       }
+//       exit(0);
+//     }
+//   }
+//   exit(0);
+// }
+
+// // what if two children exit() at the same time?
+// void
+// twochildren(char *s)
+// {
+//   for(int i = 0; i < 1000; i++){
+//     int pid1 = fork();
+//     if(pid1 < 0){
+//       printf("%s: fork failed\n", s);
+//       exit(1);
+//     }
+//     if(pid1 == 0){
+//       exit(0);
+//     } else {
+//       int pid2 = fork();
+//       if(pid2 < 0){
+//         printf("%s: fork failed\n", s);
+//         exit(1);
+//       }
+//       if(pid2 == 0){
+//         exit(0);
+//       } else {
+//         wait(0);
+//         wait(0);
+//       }
+//     }
+//   }
+// }
+
+// // concurrent forks to try to expose locking bugs.
+// void
+// forkfork(char *s)
+// {
+//   enum { N=2 };
+  
+//   for(int i = 0; i < N; i++){
+//     int pid = fork();
+//     if(pid < 0){
+//       printf("%s: fork failed", s);
+//       exit(1);
+//     }
+//     if(pid == 0){
+//       for(int j = 0; j < 200; j++){
+//         int pid1 = fork();
+//         if(pid1 < 0){
+//           exit(1);
+//         }
+//         if(pid1 == 0){
+//           exit(0);
+//         }
+//         wait(0);
+//       }
+//       exit(0);
+//     }
+//   }
+
+//   int xstatus;
+//   for(int i = 0; i < N; i++){
+//     wait(&xstatus);
+//     if(xstatus != 0) {
+//       printf("%s: fork in child failed", s);
+//       exit(1);
+//     }
+//   }
+// }
+
+// void
+// forkforkfork(char *s)
+// {
+//   unlink("stopforking");
+
+//   int pid = fork();
+//   if(pid < 0){
+//     printf("%s: fork failed", s);
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     while(1){
+//       int fd = open("stopforking", 0);
+//       if(fd >= 0){
+//         exit(0);
+//       }
+//       if(fork() < 0){
+//         close(open("stopforking", O_CREATE|O_RDWR));
+//       }
+//     }
+
+//     exit(0);
+//   }
+
+//   sleep(20); // two seconds
+//   close(open("stopforking", O_CREATE|O_RDWR));
+//   wait(0);
+//   sleep(10); // one second
+// }
+
+// // regression test. does reparent() violate the parent-then-child
+// // locking order when giving away a child to init, so that exit()
+// // deadlocks against init's wait()? also used to trigger a "panic:
+// // release" due to exit() releasing a different p->parent->lock than
+// // it acquired.
+// void
+// reparent2(char *s)
+// {
+//   for(int i = 0; i < 800; i++){
+//     int pid1 = fork();
+//     if(pid1 < 0){
+//       printf("fork failed\n");
+//       exit(1);
+//     }
+//     if(pid1 == 0){
+//       fork();
+//       fork();
+//       exit(0);
+//     }
+//     wait(0);
+//   }
+
+//   exit(0);
+// }
+
+// // allocate all mem, free it, and allocate again
+// void
+// mem(char *s)
+// {
+//   void *m1, *m2;
+//   int pid;
+
+//   if((pid = fork()) == 0){
+//     m1 = 0;
+//     while((m2 = malloc(10001)) != 0){
+//       *(char**)m2 = m1;
+//       m1 = m2;
+//     }
+//     while(m1){
+//       m2 = *(char**)m1;
+//       free(m1);
+//       m1 = m2;
+//     }
+//     m1 = malloc(1024*20);
+//     if(m1 == 0){
+//       printf("couldn't allocate mem?!!\n", s);
+//       exit(1);
+//     }
+//     free(m1);
+//     exit(0);
+//   } else {
+//     int xstatus;
+//     wait(&xstatus);
+//     if(xstatus == -1){
+//       // probably page fault, so might be lazy lab,
+//       // so OK.
+//       exit(0);
+//     }
+//     exit(xstatus);
+//   }
+// }
+
+// // More file system tests
+
+// // two processes write to the same file descriptor
+// // is the offset shared? does inode locking work?
+// void
+// sharedfd(char *s)
+// {
+//   int fd, pid, i, n, nc, np;
+//   enum { N = 1000, SZ=10};
+//   char buf[SZ];
+
+//   unlink("sharedfd");
+//   fd = open("sharedfd", O_CREATE|O_RDWR);
+//   if(fd < 0){
+//     printf("%s: cannot open sharedfd for writing", s);
+//     exit(1);
+//   }
+//   pid = fork();
+//   memset(buf, pid==0?'c':'p', sizeof(buf));
+//   for(i = 0; i < N; i++){
+//     if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+//       printf("%s: write sharedfd failed\n", s);
+//       exit(1);
+//     }
+//   }
+//   if(pid == 0) {
+//     exit(0);
+//   } else {
+//     int xstatus;
+//     wait(&xstatus);
+//     if(xstatus != 0)
+//       exit(xstatus);
+//   }
+  
+//   close(fd);
+//   fd = open("sharedfd", 0);
+//   if(fd < 0){
+//     printf("%s: cannot open sharedfd for reading\n", s);
+//     exit(1);
+//   }
+//   nc = np = 0;
+//   while((n = read(fd, buf, sizeof(buf))) > 0){
+//     for(i = 0; i < sizeof(buf); i++){
+//       if(buf[i] == 'c')
+//         nc++;
+//       if(buf[i] == 'p')
+//         np++;
+//     }
+//   }
+//   close(fd);
+//   unlink("sharedfd");
+//   if(nc == N*SZ && np == N*SZ){
+//     exit(0);
+//   } else {
+//     printf("%s: nc/np test fails\n", s);
+//     exit(1);
+//   }
+// }
+
+// // four processes write different files at the same
+// // time, to test block allocation.
+// void
+// fourfiles(char *s)
+// {
+//   int fd, pid, i, j, n, total, pi;
+//   char *names[] = { "f0", "f1", "f2", "f3" };
+//   char *fname;
+//   enum { N=12, NCHILD=4, SZ=500 };
+  
+//   for(pi = 0; pi < NCHILD; pi++){
+//     fname = names[pi];
+//     unlink(fname);
+
+//     pid = fork();
+//     if(pid < 0){
+//       printf("fork failed\n", s);
+//       exit(1);
+//     }
+
+//     if(pid == 0){
+//       fd = open(fname, O_CREATE | O_RDWR);
+//       if(fd < 0){
+//         printf("create failed\n", s);
+//         exit(1);
+//       }
+
+//       memset(buf, '0'+pi, SZ);
+//       for(i = 0; i < N; i++){
+//         if((n = write(fd, buf, SZ)) != SZ){
+//           printf("write failed %d\n", n);
+//           exit(1);
+//         }
+//       }
+//       exit(0);
+//     }
+//   }
+
+//   int xstatus;
+//   for(pi = 0; pi < NCHILD; pi++){
+//     wait(&xstatus);
+//     if(xstatus != 0)
+//       exit(xstatus);
+//   }
+
+//   for(i = 0; i < NCHILD; i++){
+//     fname = names[i];
+//     fd = open(fname, 0);
+//     total = 0;
+//     while((n = read(fd, buf, sizeof(buf))) > 0){
+//       for(j = 0; j < n; j++){
+//         if(buf[j] != '0'+i){
+//           printf("wrong char\n", s);
+//           exit(1);
+//         }
+//       }
+//       total += n;
+//     }
+//     close(fd);
+//     if(total != N*SZ){
+//       printf("wrong length %d\n", total);
+//       exit(1);
+//     }
+//     unlink(fname);
+//   }
+// }
+
+// // four processes create and delete different files in same directory
+// void
+// createdelete(char *s)
+// {
+//   enum { N = 20, NCHILD=4 };
+//   int pid, i, fd, pi;
+//   char name[32];
+
+//   for(pi = 0; pi < NCHILD; pi++){
+//     pid = fork();
+//     if(pid < 0){
+//       printf("fork failed\n", s);
+//       exit(1);
+//     }
+
+//     if(pid == 0){
+//       name[0] = 'p' + pi;
+//       name[2] = '\0';
+//       for(i = 0; i < N; i++){
+//         name[1] = '0' + i;
+//         fd = open(name, O_CREATE | O_RDWR);
+//         if(fd < 0){
+//           printf("%s: create failed\n", s);
+//           exit(1);
+//         }
+//         close(fd);
+//         if(i > 0 && (i % 2 ) == 0){
+//           name[1] = '0' + (i / 2);
+//           if(unlink(name) < 0){
+//             printf("%s: unlink failed\n", s);
+//             exit(1);
+//           }
+//         }
+//       }
+//       exit(0);
+//     }
+//   }
+
+//   int xstatus;
+//   for(pi = 0; pi < NCHILD; pi++){
+//     wait(&xstatus);
+//     if(xstatus != 0)
+//       exit(1);
+//   }
+
+//   name[0] = name[1] = name[2] = 0;
+//   for(i = 0; i < N; i++){
+//     for(pi = 0; pi < NCHILD; pi++){
+//       name[0] = 'p' + pi;
+//       name[1] = '0' + i;
+//       fd = open(name, 0);
+//       if((i == 0 || i >= N/2) && fd < 0){
+//         printf("%s: oops createdelete %s didn't exist\n", s, name);
+//         exit(1);
+//       } else if((i >= 1 && i < N/2) && fd >= 0){
+//         printf("%s: oops createdelete %s did exist\n", s, name);
+//         exit(1);
+//       }
+//       if(fd >= 0)
+//         close(fd);
+//     }
+//   }
+
+//   for(i = 0; i < N; i++){
+//     for(pi = 0; pi < NCHILD; pi++){
+//       name[0] = 'p' + i;
+//       name[1] = '0' + i;
+//       unlink(name);
+//     }
+//   }
+// }
+
+// // can I unlink a file and still read it?
+// void
+// unlinkread(char *s)
+// {
+//   enum { SZ = 5 };
+//   int fd, fd1;
+
+//   fd = open("unlinkread", O_CREATE | O_RDWR);
+//   if(fd < 0){
+//     printf("%s: create unlinkread failed\n", s);
+//     exit(1);
+//   }
+//   write(fd, "hello", SZ);
+//   close(fd);
+
+//   fd = open("unlinkread", O_RDWR);
+//   if(fd < 0){
+//     printf("%s: open unlinkread failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink("unlinkread") != 0){
+//     printf("%s: unlink unlinkread failed\n", s);
+//     exit(1);
+//   }
+
+//   fd1 = open("unlinkread", O_CREATE | O_RDWR);
+//   write(fd1, "yyy", 3);
+//   close(fd1);
+
+//   if(read(fd, buf, sizeof(buf)) != SZ){
+//     printf("%s: unlinkread read failed", s);
+//     exit(1);
+//   }
+//   if(buf[0] != 'h'){
+//     printf("%s: unlinkread wrong data\n", s);
+//     exit(1);
+//   }
+//   if(write(fd, buf, 10) != 10){
+//     printf("%s: unlinkread write failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+//   unlink("unlinkread");
+// }
+
+// void
+// linktest(char *s)
+// {
+//   enum { SZ = 5 };
+//   int fd;
+
+//   unlink("lf1");
+//   unlink("lf2");
+
+//   fd = open("lf1", O_CREATE|O_RDWR);
+//   if(fd < 0){
+//     printf("%s: create lf1 failed\n", s);
+//     exit(1);
+//   }
+//   if(write(fd, "hello", SZ) != SZ){
+//     printf("%s: write lf1 failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   if(link("lf1", "lf2") < 0){
+//     printf("%s: link lf1 lf2 failed\n", s);
+//     exit(1);
+//   }
+//   unlink("lf1");
+
+//   if(open("lf1", 0) >= 0){
+//     printf("%s: unlinked lf1 but it is still there!\n", s);
+//     exit(1);
+//   }
+
+//   fd = open("lf2", 0);
+//   if(fd < 0){
+//     printf("%s: open lf2 failed\n", s);
+//     exit(1);
+//   }
+//   if(read(fd, buf, sizeof(buf)) != SZ){
+//     printf("%s: read lf2 failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   if(link("lf2", "lf2") >= 0){
+//     printf("%s: link lf2 lf2 succeeded! oops\n", s);
+//     exit(1);
+//   }
+
+//   unlink("lf2");
+//   if(link("lf2", "lf1") >= 0){
+//     printf("%s: link non-existant succeeded! oops\n", s);
+//     exit(1);
+//   }
+
+//   if(link(".", "lf1") >= 0){
+//     printf("%s: link . lf1 succeeded! oops\n", s);
+//     exit(1);
+//   }
+// }
+
+// // test concurrent create/link/unlink of the same file
+// void
+// concreate(char *s)
+// {
+//   enum { N = 40 };
+//   char file[3];
+//   int i, pid, n, fd;
+//   char fa[N];
+//   struct {
+//     ushort inum;
+//     char name[DIRSIZ];
+//   } de;
+
+//   file[0] = 'C';
+//   file[2] = '\0';
+//   for(i = 0; i < N; i++){
+//     file[1] = '0' + i;
+//     unlink(file);
+//     pid = fork();
+//     if(pid && (i % 3) == 1){
+//       link("C0", file);
+//     } else if(pid == 0 && (i % 5) == 1){
+//       link("C0", file);
+//     } else {
+//       fd = open(file, O_CREATE | O_RDWR);
+//       if(fd < 0){
+//         printf("concreate create %s failed\n", file);
+//         exit(1);
+//       }
+//       close(fd);
+//     }
+//     if(pid == 0) {
+//       exit(0);
+//     } else {
+//       int xstatus;
+//       wait(&xstatus);
+//       if(xstatus != 0)
+//         exit(1);
+//     }
+//   }
+
+//   memset(fa, 0, sizeof(fa));
+//   fd = open(".", 0);
+//   n = 0;
+//   while(read(fd, &de, sizeof(de)) > 0){
+//     if(de.inum == 0)
+//       continue;
+//     if(de.name[0] == 'C' && de.name[2] == '\0'){
+//       i = de.name[1] - '0';
+//       if(i < 0 || i >= sizeof(fa)){
+//         printf("%s: concreate weird file %s\n", s, de.name);
+//         exit(1);
+//       }
+//       if(fa[i]){
+//         printf("%s: concreate duplicate file %s\n", s, de.name);
+//         exit(1);
+//       }
+//       fa[i] = 1;
+//       n++;
+//     }
+//   }
+//   close(fd);
+
+//   if(n != N){
+//     printf("%s: concreate not enough files in directory listing\n", s);
+//     exit(1);
+//   }
+
+//   for(i = 0; i < N; i++){
+//     file[1] = '0' + i;
+//     pid = fork();
+//     if(pid < 0){
+//       printf("%s: fork failed\n", s);
+//       exit(1);
+//     }
+//     if(((i % 3) == 0 && pid == 0) ||
+//        ((i % 3) == 1 && pid != 0)){
+//       close(open(file, 0));
+//       close(open(file, 0));
+//       close(open(file, 0));
+//       close(open(file, 0));
+//       close(open(file, 0));
+//       close(open(file, 0));
+//     } else {
+//       unlink(file);
+//       unlink(file);
+//       unlink(file);
+//       unlink(file);
+//       unlink(file);
+//       unlink(file);
+//     }
+//     if(pid == 0)
+//       exit(0);
+//     else
+//       wait(0);
+//   }
+// }
+
+// // another concurrent link/unlink/create test,
+// // to look for deadlocks.
+// void
+// linkunlink(char *s)
+// {
+//   int pid, i;
+
+//   unlink("x");
+//   pid = fork();
+//   if(pid < 0){
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+
+//   unsigned int x = (pid ? 1 : 97);
+//   for(i = 0; i < 100; i++){
+//     x = x * 1103515245 + 12345;
+//     if((x % 3) == 0){
+//       close(open("x", O_RDWR | O_CREATE));
+//     } else if((x % 3) == 1){
+//       link("cat", "x");
+//     } else {
+//       unlink("x");
+//     }
+//   }
+
+//   if(pid)
+//     wait(0);
+//   else
+//     exit(0);
+// }
+
+// // directory that uses indirect blocks
+// void
+// bigdir(char *s)
+// {
+//   enum { N = 500 };
+//   int i, fd;
+//   char name[10];
+
+//   unlink("bd");
+
+//   fd = open("bd", O_CREATE);
+//   if(fd < 0){
+//     printf("%s: bigdir create failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   for(i = 0; i < N; i++){
+//     name[0] = 'x';
+//     name[1] = '0' + (i / 64);
+//     name[2] = '0' + (i % 64);
+//     name[3] = '\0';
+//     if(link("bd", name) != 0){
+//       printf("%s: bigdir link(bd, %s) failed\n", s, name);
+//       exit(1);
+//     }
+//   }
+
+//   unlink("bd");
+//   for(i = 0; i < N; i++){
+//     name[0] = 'x';
+//     name[1] = '0' + (i / 64);
+//     name[2] = '0' + (i % 64);
+//     name[3] = '\0';
+//     if(unlink(name) != 0){
+//       printf("%s: bigdir unlink failed", s);
+//       exit(1);
+//     }
+//   }
+// }
+
+// void
+// subdir(char *s)
+// {
+//   int fd, cc;
+
+//   unlink("ff");
+//   if(mkdir("dd") != 0){
+//     printf("%s: mkdir dd failed\n", s);
+//     exit(1);
+//   }
+
+//   fd = open("dd/ff", O_CREATE | O_RDWR);
+//   if(fd < 0){
+//     printf("%s: create dd/ff failed\n", s);
+//     exit(1);
+//   }
+//   write(fd, "ff", 2);
+//   close(fd);
+
+//   if(unlink("dd") >= 0){
+//     printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
+//     exit(1);
+//   }
+
+//   if(mkdir("/dd/dd") != 0){
+//     printf("subdir mkdir dd/dd failed\n", s);
+//     exit(1);
+//   }
+
+//   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+//   if(fd < 0){
+//     printf("%s: create dd/dd/ff failed\n", s);
+//     exit(1);
+//   }
+//   write(fd, "FF", 2);
+//   close(fd);
+
+//   fd = open("dd/dd/../ff", 0);
+//   if(fd < 0){
+//     printf("%s: open dd/dd/../ff failed\n", s);
+//     exit(1);
+//   }
+//   cc = read(fd, buf, sizeof(buf));
+//   if(cc != 2 || buf[0] != 'f'){
+//     printf("%s: dd/dd/../ff wrong content\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+//     printf("link dd/dd/ff dd/dd/ffff failed\n", s);
+//     exit(1);
+//   }
+
+//   if(unlink("dd/dd/ff") != 0){
+//     printf("%s: unlink dd/dd/ff failed\n", s);
+//     exit(1);
+//   }
+//   if(open("dd/dd/ff", O_RDONLY) >= 0){
+//     printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
+//     exit(1);
+//   }
+
+//   if(chdir("dd") != 0){
+//     printf("%s: chdir dd failed\n", s);
+//     exit(1);
+//   }
+//   if(chdir("dd/../../dd") != 0){
+//     printf("%s: chdir dd/../../dd failed\n", s);
+//     exit(1);
+//   }
+//   if(chdir("dd/../../../dd") != 0){
+//     printf("chdir dd/../../dd failed\n", s);
+//     exit(1);
+//   }
+//   if(chdir("./..") != 0){
+//     printf("%s: chdir ./.. failed\n", s);
+//     exit(1);
+//   }
+
+//   fd = open("dd/dd/ffff", 0);
+//   if(fd < 0){
+//     printf("%s: open dd/dd/ffff failed\n", s);
+//     exit(1);
+//   }
+//   if(read(fd, buf, sizeof(buf)) != 2){
+//     printf("%s: read dd/dd/ffff wrong len\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   if(open("dd/dd/ff", O_RDONLY) >= 0){
+//     printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
+//     exit(1);
+//   }
+
+//   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+//     printf("%s: create dd/ff/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+//     printf("%s: create dd/xx/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(open("dd", O_CREATE) >= 0){
+//     printf("%s: create dd succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(open("dd", O_RDWR) >= 0){
+//     printf("%s: open dd rdwr succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(open("dd", O_WRONLY) >= 0){
+//     printf("%s: open dd wronly succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(link("dd/ff/ff", "dd/dd/xx") == 0){
+//     printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(link("dd/xx/ff", "dd/dd/xx") == 0){
+//     printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(link("dd/ff", "dd/dd/ffff") == 0){
+//     printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(mkdir("dd/ff/ff") == 0){
+//     printf("%s: mkdir dd/ff/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(mkdir("dd/xx/ff") == 0){
+//     printf("%s: mkdir dd/xx/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(mkdir("dd/dd/ffff") == 0){
+//     printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dd/xx/ff") == 0){
+//     printf("%s: unlink dd/xx/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dd/ff/ff") == 0){
+//     printf("%s: unlink dd/ff/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(chdir("dd/ff") == 0){
+//     printf("%s: chdir dd/ff succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(chdir("dd/xx") == 0){
+//     printf("%s: chdir dd/xx succeeded!\n", s);
+//     exit(1);
+//   }
+
+//   if(unlink("dd/dd/ffff") != 0){
+//     printf("%s: unlink dd/dd/ff failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dd/ff") != 0){
+//     printf("%s: unlink dd/ff failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dd") == 0){
+//     printf("%s: unlink non-empty dd succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dd/dd") < 0){
+//     printf("%s: unlink dd/dd failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dd") < 0){
+//     printf("%s: unlink dd failed\n", s);
+//     exit(1);
+//   }
+// }
+
+// // test writes that are larger than the log.
+// void
+// bigwrite(char *s)
+// {
+//   int fd, sz;
+
+//   unlink("bigwrite");
+//   for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
+//     fd = open("bigwrite", O_CREATE | O_RDWR);
+//     if(fd < 0){
+//       printf("%s: cannot create bigwrite\n", s);
+//       exit(1);
+//     }
+//     int i;
+//     for(i = 0; i < 2; i++){
+//       int cc = write(fd, buf, sz);
+//       if(cc != sz){
+//         printf("%s: write(%d) ret %d\n", s, sz, cc);
+//         exit(1);
+//       }
+//     }
+//     close(fd);
+//     unlink("bigwrite");
+//   }
+// }
 
-// does exit() call iput(p->cwd) in a transaction?
+// concurrent writes to try to provoke deadlock in the virtio disk
+// driver.
 void
-exitiputtest(char *s)
+manywrites(char *s)
 {
-  int pid, xstatus;
-
-  pid = fork();
-  if(pid < 0){
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-  if(pid == 0){
-    if(mkdir("iputdir") < 0){
-      printf("%s: mkdir failed\n", s);
-      exit(1);
-    }
-    if(chdir("iputdir") < 0){
-      printf("%s: child chdir failed\n", s);
-      exit(1);
-    }
-    if(unlink("../iputdir") < 0){
-      printf("%s: unlink ../iputdir failed\n", s);
+  int nchildren = 4;
+  int howmany = 30; // increase to look for deadlock
+  
+  for(int ci = 0; ci < nchildren; ci++){
+    int pid = fork();
+    if(pid < 0){
+      printf("fork failed\n");
       exit(1);
     }
-    exit(0);
-  }
-  wait(&xstatus);
-  exit(xstatus);
-}
 
-// does the error path in open() for attempt to write a
-// directory call iput() in a transaction?
-// needs a hacked kernel that pauses just after the namei()
-// call in sys_open():
-//    if((ip = namei(path)) == 0)
-//      return -1;
-//    {
-//      int i;
-//      for(i = 0; i < 10000; i++)
-//        yield();
-//    }
-void
-openiputtest(char *s)
-{
-  int pid, xstatus;
+    if(pid == 0){
+      char name[3];
+      name[0] = 'b';
+      name[1] = 'a' + ci;
+      name[2] = '\0';
+      unlink(name);
+      
+      for(int iters = 0; iters < howmany; iters++){
+        for(int i = 0; i < ci+1; i++){
+          int fd = open(name, O_CREATE | O_RDWR);
+          if(fd < 0){
+            printf("%s: cannot create %s\n", s, name);
+            exit(1);
+          }
+          int sz = sizeof(buf);
+          int cc = write(fd, buf, sz);
+          if(cc != sz){
+            printf("%s: write(%d) ret %d\n", s, sz, cc);
+            exit(1);
+          }
+          close(fd);
+        }
+        unlink(name);
+      }
 
-  if(mkdir("oidir") < 0){
-    printf("%s: mkdir oidir failed\n", s);
-    exit(1);
-  }
-  pid = fork();
-  if(pid < 0){
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-  if(pid == 0){
-    int fd = open("oidir", O_RDWR);
-    if(fd >= 0){
-      printf("%s: open directory for write succeeded\n", s);
-      exit(1);
+      unlink(name);
+      exit(0);
     }
-    exit(0);
   }
-  sleep(1);
-  if(unlink("oidir") != 0){
-    printf("%s: unlink failed\n", s);
-    exit(1);
+
+  for(int ci = 0; ci < nchildren; ci++){
+    int st = 0;
+    wait(&st);
+    if(st != 0)
+      exit(st);
   }
-  wait(&xstatus);
-  exit(xstatus);
+  exit(0);
 }
 
-// simple file system tests
-
-void
-opentest(char *s)
-{
-  int fd;
-
-  fd = open("echo", 0);
-  if(fd < 0){
-    printf("%s: open echo failed!\n", s);
-    exit(1);
-  }
-  close(fd);
-  fd = open("doesnotexist", 0);
-  if(fd >= 0){
-    printf("%s: open doesnotexist succeeded!\n", s);
-    exit(1);
-  }
-}
-
-void
-writetest(char *s)
-{
-  int fd;
-  int i;
-  enum { N=100, SZ=10 };
-  
-  fd = open("small", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf("%s: error: creat small failed!\n", s);
-    exit(1);
-  }
-  for(i = 0; i < N; i++){
-    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
-      printf("%s: error: write aa %d new file failed\n", s, i);
-      exit(1);
-    }
-    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
-      printf("%s: error: write bb %d new file failed\n", s, i);
-      exit(1);
-    }
-  }
-  close(fd);
-  fd = open("small", O_RDONLY);
-  if(fd < 0){
-    printf("%s: error: open small failed!\n", s);
-    exit(1);
-  }
-  i = read(fd, buf, N*SZ*2);
-  if(i != N*SZ*2){
-    printf("%s: read failed\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  if(unlink("small") < 0){
-    printf("%s: unlink small failed\n", s);
-    exit(1);
-  }
-}
-
-void
-writebig(char *s)
-{
-  int i, fd, n;
-
-  fd = open("big", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf("%s: error: creat big failed!\n", s);
-    exit(1);
-  }
-
-  for(i = 0; i < MAXFILE; i++){
-    ((int*)buf)[0] = i;
-    if(write(fd, buf, BSIZE) != BSIZE){
-      printf("%s: error: write big file failed\n", s, i);
-      exit(1);
-    }
-  }
-
-  close(fd);
-
-  fd = open("big", O_RDONLY);
-  if(fd < 0){
-    printf("%s: error: open big failed!\n", s);
-    exit(1);
-  }
-
-  n = 0;
-  for(;;){
-    i = read(fd, buf, BSIZE);
-    if(i == 0){
-      if(n == MAXFILE - 1){
-        printf("%s: read only %d blocks from big", s, n);
-        exit(1);
-      }
-      break;
-    } else if(i != BSIZE){
-      printf("%s: read failed %d\n", s, i);
-      exit(1);
-    }
-    if(((int*)buf)[0] != n){
-      printf("%s: read content of block %d is %d\n", s,
-             n, ((int*)buf)[0]);
-      exit(1);
-    }
-    n++;
-  }
-  close(fd);
-  if(unlink("big") < 0){
-    printf("%s: unlink big failed\n", s);
-    exit(1);
-  }
-}
-
-// many creates, followed by unlink test
-void
-createtest(char *s)
-{
-  int i, fd;
-  enum { N=52 };
-
-  char name[3];
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < N; i++){
-    name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
-    close(fd);
-  }
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < N; i++){
-    name[1] = '0' + i;
-    unlink(name);
-  }
-}
-
-void dirtest(char *s)
-{
-  if(mkdir("dir0") < 0){
-    printf("%s: mkdir failed\n", s);
-    exit(1);
-  }
-
-  if(chdir("dir0") < 0){
-    printf("%s: chdir dir0 failed\n", s);
-    exit(1);
-  }
-
-  if(chdir("..") < 0){
-    printf("%s: chdir .. failed\n", s);
-    exit(1);
-  }
-
-  if(unlink("dir0") < 0){
-    printf("%s: unlink dir0 failed\n", s);
-    exit(1);
-  }
-}
-
-void
-exectest(char *s)
-{
-  int fd, xstatus, pid;
-  char *echoargv[] = { "echo", "OK", 0 };
-  char buf[3];
-
-  unlink("echo-ok");
-  pid = fork();
-  if(pid < 0) {
-     printf("%s: fork failed\n", s);
-     exit(1);
-  }
-  if(pid == 0) {
-    close(1);
-    fd = open("echo-ok", O_CREATE|O_WRONLY);
-    if(fd < 0) {
-      printf("%s: create failed\n", s);
-      exit(1);
-    }
-    if(fd != 1) {
-      printf("%s: wrong fd\n", s);
-      exit(1);
-    }
-    if(exec("echo", echoargv) < 0){
-      printf("%s: exec echo failed\n", s);
-      exit(1);
-    }
-    // won't get to here
-  }
-  if (wait(&xstatus) != pid) {
-    printf("%s: wait failed!\n", s);
-  }
-  if(xstatus != 0)
-    exit(xstatus);
-
-  fd = open("echo-ok", O_RDONLY);
-  if(fd < 0) {
-    printf("%s: open failed\n", s);
-    exit(1);
-  }
-  if (read(fd, buf, 2) != 2) {
-    printf("%s: read failed\n", s);
-    exit(1);
-  }
-  unlink("echo-ok");
-  if(buf[0] == 'O' && buf[1] == 'K')
-    exit(0);
-  else {
-    printf("%s: wrong output\n", s);
-    exit(1);
-  }
-
-}
-
-// simple fork and pipe read/write
-
-void
-pipe1(char *s)
-{
-  int fds[2], pid, xstatus;
-  int seq, i, n, cc, total;
-  enum { N=5, SZ=1033 };
-  
-  if(pipe(fds) != 0){
-    printf("%s: pipe() failed\n", s);
-    exit(1);
-  }
-  pid = fork();
-  seq = 0;
-  if(pid == 0){
-    close(fds[0]);
-    for(n = 0; n < N; n++){
-      for(i = 0; i < SZ; i++)
-        buf[i] = seq++;
-      if(write(fds[1], buf, SZ) != SZ){
-        printf("%s: pipe1 oops 1\n", s);
-        exit(1);
-      }
-    }
-    exit(0);
-  } else if(pid > 0){
-    close(fds[1]);
-    total = 0;
-    cc = 1;
-    while((n = read(fds[0], buf, cc)) > 0){
-      for(i = 0; i < n; i++){
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
-          printf("%s: pipe1 oops 2\n", s);
-          return;
-        }
-      }
-      total += n;
-      cc = cc * 2;
-      if(cc > sizeof(buf))
-        cc = sizeof(buf);
-    }
-    if(total != N * SZ){
-      printf("%s: pipe1 oops 3 total %d\n", total);
-      exit(1);
-    }
-    close(fds[0]);
-    wait(&xstatus);
-    exit(xstatus);
-  } else {
-    printf("%s: fork() failed\n", s);
-    exit(1);
-  }
-}
-
-
-// test if child is killed (status = -1)
-void
-killstatus(char *s)
-{
-  int xst;
-  
-  for(int i = 0; i < 100; i++){
-    int pid1 = fork();
-    if(pid1 < 0){
-      printf("%s: fork failed\n", s);
-      exit(1);
-    }
-    if(pid1 == 0){
-      while(1) {
-        getpid();
-      }
-      exit(0);
-    }
-    sleep(1);
-    kill(pid1);
-    wait(&xst);
-    if(xst != -1) {
-       printf("%s: status should be -1\n", s);
-       exit(1);
-    }
-  }
-  exit(0);
-}
-
-// meant to be run w/ at most two CPUs
-void
-preempt(char *s)
-{
-  int pid1, pid2, pid3;
-  int pfds[2];
-
-  pid1 = fork();
-  if(pid1 < 0) {
-    printf("%s: fork failed", s);
-    exit(1);
-  }
-  if(pid1 == 0)
-    for(;;)
-      ;
-
-  pid2 = fork();
-  if(pid2 < 0) {
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-  if(pid2 == 0)
-    for(;;)
-      ;
-
-  pipe(pfds);
-  pid3 = fork();
-  if(pid3 < 0) {
-     printf("%s: fork failed\n", s);
-     exit(1);
-  }
-  if(pid3 == 0){
-    close(pfds[0]);
-    if(write(pfds[1], "x", 1) != 1)
-      printf("%s: preempt write error", s);
-    close(pfds[1]);
-    for(;;)
-      ;
-  }
-
-  close(pfds[1]);
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
-    printf("%s: preempt read error", s);
-    return;
-  }
-  close(pfds[0]);
-  printf("kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
-  printf("wait... ");
-  wait(0);
-  wait(0);
-  wait(0);
-}
-
-// try to find any races between exit and wait
-void
-exitwait(char *s)
-{
-  int i, pid;
-
-  for(i = 0; i < 100; i++){
-    pid = fork();
-    if(pid < 0){
-      printf("%s: fork failed\n", s);
-      exit(1);
-    }
-    if(pid){
-      int xstate;
-      if(wait(&xstate) != pid){
-        printf("%s: wait wrong pid\n", s);
-        exit(1);
-      }
-      if(i != xstate) {
-        printf("%s: wait wrong exit status\n", s);
-        exit(1);
-      }
-    } else {
-      exit(i);
-    }
-  }
-}
-
-// try to find races in the reparenting
-// code that handles a parent exiting
-// when it still has live children.
-void
-reparent(char *s)
-{
-  int master_pid = getpid();
-  for(int i = 0; i < 200; i++){
-    int pid = fork();
-    if(pid < 0){
-      printf("%s: fork failed\n", s);
-      exit(1);
-    }
-    if(pid){
-      if(wait(0) != pid){
-        printf("%s: wait wrong pid\n", s);
-        exit(1);
-      }
-    } else {
-      int pid2 = fork();
-      if(pid2 < 0){
-        kill(master_pid);
-        exit(1);
-      }
-      exit(0);
-    }
-  }
-  exit(0);
-}
-
-// what if two children exit() at the same time?
-void
-twochildren(char *s)
-{
-  for(int i = 0; i < 1000; i++){
-    int pid1 = fork();
-    if(pid1 < 0){
-      printf("%s: fork failed\n", s);
-      exit(1);
-    }
-    if(pid1 == 0){
-      exit(0);
-    } else {
-      int pid2 = fork();
-      if(pid2 < 0){
-        printf("%s: fork failed\n", s);
-        exit(1);
-      }
-      if(pid2 == 0){
-        exit(0);
-      } else {
-        wait(0);
-        wait(0);
-      }
-    }
-  }
-}
-
-// concurrent forks to try to expose locking bugs.
-void
-forkfork(char *s)
-{
-  enum { N=2 };
-  
-  for(int i = 0; i < N; i++){
-    int pid = fork();
-    if(pid < 0){
-      printf("%s: fork failed", s);
-      exit(1);
-    }
-    if(pid == 0){
-      for(int j = 0; j < 200; j++){
-        int pid1 = fork();
-        if(pid1 < 0){
-          exit(1);
-        }
-        if(pid1 == 0){
-          exit(0);
-        }
-        wait(0);
-      }
-      exit(0);
-    }
-  }
-
-  int xstatus;
-  for(int i = 0; i < N; i++){
-    wait(&xstatus);
-    if(xstatus != 0) {
-      printf("%s: fork in child failed", s);
-      exit(1);
-    }
-  }
-}
-
-void
-forkforkfork(char *s)
-{
-  unlink("stopforking");
-
-  int pid = fork();
-  if(pid < 0){
-    printf("%s: fork failed", s);
-    exit(1);
-  }
-  if(pid == 0){
-    while(1){
-      int fd = open("stopforking", 0);
-      if(fd >= 0){
-        exit(0);
-      }
-      if(fork() < 0){
-        close(open("stopforking", O_CREATE|O_RDWR));
-      }
-    }
-
-    exit(0);
-  }
-
-  sleep(20); // two seconds
-  close(open("stopforking", O_CREATE|O_RDWR));
-  wait(0);
-  sleep(10); // one second
-}
-
-// regression test. does reparent() violate the parent-then-child
-// locking order when giving away a child to init, so that exit()
-// deadlocks against init's wait()? also used to trigger a "panic:
-// release" due to exit() releasing a different p->parent->lock than
-// it acquired.
-void
-reparent2(char *s)
-{
-  for(int i = 0; i < 800; i++){
-    int pid1 = fork();
-    if(pid1 < 0){
-      printf("fork failed\n");
-      exit(1);
-    }
-    if(pid1 == 0){
-      fork();
-      fork();
-      exit(0);
-    }
-    wait(0);
-  }
-
-  exit(0);
-}
-
-// allocate all mem, free it, and allocate again
-void
-mem(char *s)
-{
-  void *m1, *m2;
-  int pid;
-
-  if((pid = fork()) == 0){
-    m1 = 0;
-    while((m2 = malloc(10001)) != 0){
-      *(char**)m2 = m1;
-      m1 = m2;
-    }
-    while(m1){
-      m2 = *(char**)m1;
-      free(m1);
-      m1 = m2;
-    }
-    m1 = malloc(1024*20);
-    if(m1 == 0){
-      printf("couldn't allocate mem?!!\n", s);
-      exit(1);
-    }
-    free(m1);
-    exit(0);
-  } else {
-    int xstatus;
-    wait(&xstatus);
-    if(xstatus == -1){
-      // probably page fault, so might be lazy lab,
-      // so OK.
-      exit(0);
-    }
-    exit(xstatus);
-  }
-}
-
-// More file system tests
-
-// two processes write to the same file descriptor
-// is the offset shared? does inode locking work?
-void
-sharedfd(char *s)
-{
-  int fd, pid, i, n, nc, np;
-  enum { N = 1000, SZ=10};
-  char buf[SZ];
-
-  unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf("%s: cannot open sharedfd for writing", s);
-    exit(1);
-  }
-  pid = fork();
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-  for(i = 0; i < N; i++){
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
-      printf("%s: write sharedfd failed\n", s);
-      exit(1);
-    }
-  }
-  if(pid == 0) {
-    exit(0);
-  } else {
-    int xstatus;
-    wait(&xstatus);
-    if(xstatus != 0)
-      exit(xstatus);
-  }
-  
-  close(fd);
-  fd = open("sharedfd", 0);
-  if(fd < 0){
-    printf("%s: cannot open sharedfd for reading\n", s);
-    exit(1);
-  }
-  nc = np = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i = 0; i < sizeof(buf); i++){
-      if(buf[i] == 'c')
-        nc++;
-      if(buf[i] == 'p')
-        np++;
-    }
-  }
-  close(fd);
-  unlink("sharedfd");
-  if(nc == N*SZ && np == N*SZ){
-    exit(0);
-  } else {
-    printf("%s: nc/np test fails\n", s);
-    exit(1);
-  }
-}
-
-// four processes write different files at the same
-// time, to test block allocation.
-void
-fourfiles(char *s)
-{
-  int fd, pid, i, j, n, total, pi;
-  char *names[] = { "f0", "f1", "f2", "f3" };
-  char *fname;
-  enum { N=12, NCHILD=4, SZ=500 };
-  
-  for(pi = 0; pi < NCHILD; pi++){
-    fname = names[pi];
-    unlink(fname);
-
-    pid = fork();
-    if(pid < 0){
-      printf("fork failed\n", s);
-      exit(1);
-    }
-
-    if(pid == 0){
-      fd = open(fname, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf("create failed\n", s);
-        exit(1);
-      }
-
-      memset(buf, '0'+pi, SZ);
-      for(i = 0; i < N; i++){
-        if((n = write(fd, buf, SZ)) != SZ){
-          printf("write failed %d\n", n);
-          exit(1);
-        }
-      }
-      exit(0);
-    }
-  }
-
-  int xstatus;
-  for(pi = 0; pi < NCHILD; pi++){
-    wait(&xstatus);
-    if(xstatus != 0)
-      exit(xstatus);
-  }
-
-  for(i = 0; i < NCHILD; i++){
-    fname = names[i];
-    fd = open(fname, 0);
-    total = 0;
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-      for(j = 0; j < n; j++){
-        if(buf[j] != '0'+i){
-          printf("wrong char\n", s);
-          exit(1);
-        }
-      }
-      total += n;
-    }
-    close(fd);
-    if(total != N*SZ){
-      printf("wrong length %d\n", total);
-      exit(1);
-    }
-    unlink(fname);
-  }
-}
-
-// four processes create and delete different files in same directory
-void
-createdelete(char *s)
-{
-  enum { N = 20, NCHILD=4 };
-  int pid, i, fd, pi;
-  char name[32];
-
-  for(pi = 0; pi < NCHILD; pi++){
-    pid = fork();
-    if(pid < 0){
-      printf("fork failed\n", s);
-      exit(1);
-    }
-
-    if(pid == 0){
-      name[0] = 'p' + pi;
-      name[2] = '\0';
-      for(i = 0; i < N; i++){
-        name[1] = '0' + i;
-        fd = open(name, O_CREATE | O_RDWR);
-        if(fd < 0){
-          printf("%s: create failed\n", s);
-          exit(1);
-        }
-        close(fd);
-        if(i > 0 && (i % 2 ) == 0){
-          name[1] = '0' + (i / 2);
-          if(unlink(name) < 0){
-            printf("%s: unlink failed\n", s);
-            exit(1);
-          }
-        }
-      }
-      exit(0);
-    }
-  }
-
-  int xstatus;
-  for(pi = 0; pi < NCHILD; pi++){
-    wait(&xstatus);
-    if(xstatus != 0)
-      exit(1);
-  }
-
-  name[0] = name[1] = name[2] = 0;
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < NCHILD; pi++){
-      name[0] = 'p' + pi;
-      name[1] = '0' + i;
-      fd = open(name, 0);
-      if((i == 0 || i >= N/2) && fd < 0){
-        printf("%s: oops createdelete %s didn't exist\n", s, name);
-        exit(1);
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-        printf("%s: oops createdelete %s did exist\n", s, name);
-        exit(1);
-      }
-      if(fd >= 0)
-        close(fd);
-    }
-  }
-
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < NCHILD; pi++){
-      name[0] = 'p' + i;
-      name[1] = '0' + i;
-      unlink(name);
-    }
-  }
-}
-
-// can I unlink a file and still read it?
-void
-unlinkread(char *s)
-{
-  enum { SZ = 5 };
-  int fd, fd1;
-
-  fd = open("unlinkread", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf("%s: create unlinkread failed\n", s);
-    exit(1);
-  }
-  write(fd, "hello", SZ);
-  close(fd);
-
-  fd = open("unlinkread", O_RDWR);
-  if(fd < 0){
-    printf("%s: open unlinkread failed\n", s);
-    exit(1);
-  }
-  if(unlink("unlinkread") != 0){
-    printf("%s: unlink unlinkread failed\n", s);
-    exit(1);
-  }
-
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
-  write(fd1, "yyy", 3);
-  close(fd1);
-
-  if(read(fd, buf, sizeof(buf)) != SZ){
-    printf("%s: unlinkread read failed", s);
-    exit(1);
-  }
-  if(buf[0] != 'h'){
-    printf("%s: unlinkread wrong data\n", s);
-    exit(1);
-  }
-  if(write(fd, buf, 10) != 10){
-    printf("%s: unlinkread write failed\n", s);
-    exit(1);
-  }
-  close(fd);
-  unlink("unlinkread");
-}
-
-void
-linktest(char *s)
-{
-  enum { SZ = 5 };
-  int fd;
-
-  unlink("lf1");
-  unlink("lf2");
-
-  fd = open("lf1", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf("%s: create lf1 failed\n", s);
-    exit(1);
-  }
-  if(write(fd, "hello", SZ) != SZ){
-    printf("%s: write lf1 failed\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  if(link("lf1", "lf2") < 0){
-    printf("%s: link lf1 lf2 failed\n", s);
-    exit(1);
-  }
-  unlink("lf1");
-
-  if(open("lf1", 0) >= 0){
-    printf("%s: unlinked lf1 but it is still there!\n", s);
-    exit(1);
-  }
-
-  fd = open("lf2", 0);
-  if(fd < 0){
-    printf("%s: open lf2 failed\n", s);
-    exit(1);
-  }
-  if(read(fd, buf, sizeof(buf)) != SZ){
-    printf("%s: read lf2 failed\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  if(link("lf2", "lf2") >= 0){
-    printf("%s: link lf2 lf2 succeeded! oops\n", s);
-    exit(1);
-  }
-
-  unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
-    printf("%s: link non-existant succeeded! oops\n", s);
-    exit(1);
-  }
-
-  if(link(".", "lf1") >= 0){
-    printf("%s: link . lf1 succeeded! oops\n", s);
-    exit(1);
-  }
-}
-
-// test concurrent create/link/unlink of the same file
-void
-concreate(char *s)
-{
-  enum { N = 40 };
-  char file[3];
-  int i, pid, n, fd;
-  char fa[N];
-  struct {
-    ushort inum;
-    char name[DIRSIZ];
-  } de;
-
-  file[0] = 'C';
-  file[2] = '\0';
-  for(i = 0; i < N; i++){
-    file[1] = '0' + i;
-    unlink(file);
-    pid = fork();
-    if(pid && (i % 3) == 1){
-      link("C0", file);
-    } else if(pid == 0 && (i % 5) == 1){
-      link("C0", file);
-    } else {
-      fd = open(file, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf("concreate create %s failed\n", file);
-        exit(1);
-      }
-      close(fd);
-    }
-    if(pid == 0) {
-      exit(0);
-    } else {
-      int xstatus;
-      wait(&xstatus);
-      if(xstatus != 0)
-        exit(1);
-    }
-  }
-
-  memset(fa, 0, sizeof(fa));
-  fd = open(".", 0);
-  n = 0;
-  while(read(fd, &de, sizeof(de)) > 0){
-    if(de.inum == 0)
-      continue;
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
-      i = de.name[1] - '0';
-      if(i < 0 || i >= sizeof(fa)){
-        printf("%s: concreate weird file %s\n", s, de.name);
-        exit(1);
-      }
-      if(fa[i]){
-        printf("%s: concreate duplicate file %s\n", s, de.name);
-        exit(1);
-      }
-      fa[i] = 1;
-      n++;
-    }
-  }
-  close(fd);
-
-  if(n != N){
-    printf("%s: concreate not enough files in directory listing\n", s);
-    exit(1);
-  }
-
-  for(i = 0; i < N; i++){
-    file[1] = '0' + i;
-    pid = fork();
-    if(pid < 0){
-      printf("%s: fork failed\n", s);
-      exit(1);
-    }
-    if(((i % 3) == 0 && pid == 0) ||
-       ((i % 3) == 1 && pid != 0)){
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-    } else {
-      unlink(file);
-      unlink(file);
-      unlink(file);
-      unlink(file);
-      unlink(file);
-      unlink(file);
-    }
-    if(pid == 0)
-      exit(0);
-    else
-      wait(0);
-  }
-}
-
-// another concurrent link/unlink/create test,
-// to look for deadlocks.
-void
-linkunlink(char *s)
-{
-  int pid, i;
-
-  unlink("x");
-  pid = fork();
-  if(pid < 0){
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-
-  unsigned int x = (pid ? 1 : 97);
-  for(i = 0; i < 100; i++){
-    x = x * 1103515245 + 12345;
-    if((x % 3) == 0){
-      close(open("x", O_RDWR | O_CREATE));
-    } else if((x % 3) == 1){
-      link("cat", "x");
-    } else {
-      unlink("x");
-    }
-  }
-
-  if(pid)
-    wait(0);
-  else
-    exit(0);
-}
-
-// directory that uses indirect blocks
-void
-bigdir(char *s)
-{
-  enum { N = 500 };
-  int i, fd;
-  char name[10];
-
-  unlink("bd");
-
-  fd = open("bd", O_CREATE);
-  if(fd < 0){
-    printf("%s: bigdir create failed\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  for(i = 0; i < N; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(link("bd", name) != 0){
-      printf("%s: bigdir link(bd, %s) failed\n", s, name);
-      exit(1);
-    }
-  }
-
-  unlink("bd");
-  for(i = 0; i < N; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(unlink(name) != 0){
-      printf("%s: bigdir unlink failed", s);
-      exit(1);
-    }
-  }
-}
-
-void
-subdir(char *s)
-{
-  int fd, cc;
-
-  unlink("ff");
-  if(mkdir("dd") != 0){
-    printf("%s: mkdir dd failed\n", s);
-    exit(1);
-  }
-
-  fd = open("dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf("%s: create dd/ff failed\n", s);
-    exit(1);
-  }
-  write(fd, "ff", 2);
-  close(fd);
-
-  if(unlink("dd") >= 0){
-    printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
-    exit(1);
-  }
-
-  if(mkdir("/dd/dd") != 0){
-    printf("subdir mkdir dd/dd failed\n", s);
-    exit(1);
-  }
-
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf("%s: create dd/dd/ff failed\n", s);
-    exit(1);
-  }
-  write(fd, "FF", 2);
-  close(fd);
-
-  fd = open("dd/dd/../ff", 0);
-  if(fd < 0){
-    printf("%s: open dd/dd/../ff failed\n", s);
-    exit(1);
-  }
-  cc = read(fd, buf, sizeof(buf));
-  if(cc != 2 || buf[0] != 'f'){
-    printf("%s: dd/dd/../ff wrong content\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-    printf("link dd/dd/ff dd/dd/ffff failed\n", s);
-    exit(1);
-  }
-
-  if(unlink("dd/dd/ff") != 0){
-    printf("%s: unlink dd/dd/ff failed\n", s);
-    exit(1);
-  }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
-    exit(1);
-  }
-
-  if(chdir("dd") != 0){
-    printf("%s: chdir dd failed\n", s);
-    exit(1);
-  }
-  if(chdir("dd/../../dd") != 0){
-    printf("%s: chdir dd/../../dd failed\n", s);
-    exit(1);
-  }
-  if(chdir("dd/../../../dd") != 0){
-    printf("chdir dd/../../dd failed\n", s);
-    exit(1);
-  }
-  if(chdir("./..") != 0){
-    printf("%s: chdir ./.. failed\n", s);
-    exit(1);
-  }
-
-  fd = open("dd/dd/ffff", 0);
-  if(fd < 0){
-    printf("%s: open dd/dd/ffff failed\n", s);
-    exit(1);
-  }
-  if(read(fd, buf, sizeof(buf)) != 2){
-    printf("%s: read dd/dd/ffff wrong len\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
-    exit(1);
-  }
-
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-    printf("%s: create dd/ff/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-    printf("%s: create dd/xx/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(open("dd", O_CREATE) >= 0){
-    printf("%s: create dd succeeded!\n", s);
-    exit(1);
-  }
-  if(open("dd", O_RDWR) >= 0){
-    printf("%s: open dd rdwr succeeded!\n", s);
-    exit(1);
-  }
-  if(open("dd", O_WRONLY) >= 0){
-    printf("%s: open dd wronly succeeded!\n", s);
-    exit(1);
-  }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
-    printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
-    exit(1);
-  }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
-    printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
-    exit(1);
-  }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
-    printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
-    exit(1);
-  }
-  if(mkdir("dd/ff/ff") == 0){
-    printf("%s: mkdir dd/ff/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(mkdir("dd/xx/ff") == 0){
-    printf("%s: mkdir dd/xx/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(mkdir("dd/dd/ffff") == 0){
-    printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
-    exit(1);
-  }
-  if(unlink("dd/xx/ff") == 0){
-    printf("%s: unlink dd/xx/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(unlink("dd/ff/ff") == 0){
-    printf("%s: unlink dd/ff/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(chdir("dd/ff") == 0){
-    printf("%s: chdir dd/ff succeeded!\n", s);
-    exit(1);
-  }
-  if(chdir("dd/xx") == 0){
-    printf("%s: chdir dd/xx succeeded!\n", s);
-    exit(1);
-  }
-
-  if(unlink("dd/dd/ffff") != 0){
-    printf("%s: unlink dd/dd/ff failed\n", s);
-    exit(1);
-  }
-  if(unlink("dd/ff") != 0){
-    printf("%s: unlink dd/ff failed\n", s);
-    exit(1);
-  }
-  if(unlink("dd") == 0){
-    printf("%s: unlink non-empty dd succeeded!\n", s);
-    exit(1);
-  }
-  if(unlink("dd/dd") < 0){
-    printf("%s: unlink dd/dd failed\n", s);
-    exit(1);
-  }
-  if(unlink("dd") < 0){
-    printf("%s: unlink dd failed\n", s);
-    exit(1);
-  }
-}
-
-// test writes that are larger than the log.
-void
-bigwrite(char *s)
-{
-  int fd, sz;
-
-  unlink("bigwrite");
-  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
-    fd = open("bigwrite", O_CREATE | O_RDWR);
-    if(fd < 0){
-      printf("%s: cannot create bigwrite\n", s);
-      exit(1);
-    }
-    int i;
-    for(i = 0; i < 2; i++){
-      int cc = write(fd, buf, sz);
-      if(cc != sz){
-        printf("%s: write(%d) ret %d\n", s, sz, cc);
-        exit(1);
-      }
-    }
-    close(fd);
-    unlink("bigwrite");
-  }
-}
-
-// concurrent writes to try to provoke deadlock in the virtio disk
-// driver.
-void
-manywrites(char *s)
-{
-  int nchildren = 4;
-  int howmany = 30; // increase to look for deadlock
-  
-  for(int ci = 0; ci < nchildren; ci++){
-    int pid = fork();
-    if(pid < 0){
-      printf("fork failed\n");
-      exit(1);
-    }
-
-    if(pid == 0){
-      char name[3];
-      name[0] = 'b';
-      name[1] = 'a' + ci;
-      name[2] = '\0';
-      unlink(name);
-      
-      for(int iters = 0; iters < howmany; iters++){
-        for(int i = 0; i < ci+1; i++){
-          int fd = open(name, O_CREATE | O_RDWR);
-          if(fd < 0){
-            printf("%s: cannot create %s\n", s, name);
-            exit(1);
-          }
-          int sz = sizeof(buf);
-          int cc = write(fd, buf, sz);
-          if(cc != sz){
-            printf("%s: write(%d) ret %d\n", s, sz, cc);
-            exit(1);
-          }
-          close(fd);
-        }
-        unlink(name);
-      }
-
-      unlink(name);
-      exit(0);
-    }
-  }
-
-  for(int ci = 0; ci < nchildren; ci++){
-    int st = 0;
-    wait(&st);
-    if(st != 0)
-      exit(st);
-  }
-  exit(0);
-}
-
-void
-bigfile(char *s)
-{
-  enum { N = 20, SZ=600 };
-  int fd, i, total, cc;
-
-  unlink("bigfile.dat");
-  fd = open("bigfile.dat", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf("%s: cannot create bigfile", s);
-    exit(1);
-  }
-  for(i = 0; i < N; i++){
-    memset(buf, i, SZ);
-    if(write(fd, buf, SZ) != SZ){
-      printf("%s: write bigfile failed\n", s);
-      exit(1);
-    }
-  }
-  close(fd);
-
-  fd = open("bigfile.dat", 0);
-  if(fd < 0){
-    printf("%s: cannot open bigfile\n", s);
-    exit(1);
-  }
-  total = 0;
-  for(i = 0; ; i++){
-    cc = read(fd, buf, SZ/2);
-    if(cc < 0){
-      printf("%s: read bigfile failed\n", s);
-      exit(1);
-    }
-    if(cc == 0)
-      break;
-    if(cc != SZ/2){
-      printf("%s: short read bigfile\n", s);
-      exit(1);
-    }
-    if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
-      printf("%s: read bigfile wrong data\n", s);
-      exit(1);
-    }
-    total += cc;
-  }
-  close(fd);
-  if(total != N*SZ){
-    printf("%s: read bigfile wrong total\n", s);
-    exit(1);
-  }
-  unlink("bigfile.dat");
-}
-
-void
-fourteen(char *s)
-{
-  int fd;
-
-  // DIRSIZ is 14.
-
-  if(mkdir("12345678901234") != 0){
-    printf("%s: mkdir 12345678901234 failed\n", s);
-    exit(1);
-  }
-  if(mkdir("12345678901234/123456789012345") != 0){
-    printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
-    exit(1);
-  }
-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-  if(fd < 0){
-    printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
-    exit(1);
-  }
-  close(fd);
-  fd = open("12345678901234/12345678901234/12345678901234", 0);
-  if(fd < 0){
-    printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  if(mkdir("12345678901234/12345678901234") == 0){
-    printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
-    exit(1);
-  }
-  if(mkdir("123456789012345/12345678901234") == 0){
-    printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
-    exit(1);
-  }
-
-  // clean up
-  unlink("123456789012345/12345678901234");
-  unlink("12345678901234/12345678901234");
-  unlink("12345678901234/12345678901234/12345678901234");
-  unlink("123456789012345/123456789012345/123456789012345");
-  unlink("12345678901234/123456789012345");
-  unlink("12345678901234");
-}
-
-void
-rmdot(char *s)
-{
-  if(mkdir("dots") != 0){
-    printf("%s: mkdir dots failed\n", s);
-    exit(1);
-  }
-  if(chdir("dots") != 0){
-    printf("%s: chdir dots failed\n", s);
-    exit(1);
-  }
-  if(unlink(".") == 0){
-    printf("%s: rm . worked!\n", s);
-    exit(1);
-  }
-  if(unlink("..") == 0){
-    printf("%s: rm .. worked!\n", s);
-    exit(1);
-  }
-  if(chdir("/") != 0){
-    printf("%s: chdir / failed\n", s);
-    exit(1);
-  }
-  if(unlink("dots/.") == 0){
-    printf("%s: unlink dots/. worked!\n", s);
-    exit(1);
-  }
-  if(unlink("dots/..") == 0){
-    printf("%s: unlink dots/.. worked!\n", s);
-    exit(1);
-  }
-  if(unlink("dots") != 0){
-    printf("%s: unlink dots failed!\n", s);
-    exit(1);
-  }
-}
-
-void
-dirfile(char *s)
-{
-  int fd;
-
-  fd = open("dirfile", O_CREATE);
-  if(fd < 0){
-    printf("%s: create dirfile failed\n", s);
-    exit(1);
-  }
-  close(fd);
-  if(chdir("dirfile") == 0){
-    printf("%s: chdir dirfile succeeded!\n", s);
-    exit(1);
-  }
-  fd = open("dirfile/xx", 0);
-  if(fd >= 0){
-    printf("%s: create dirfile/xx succeeded!\n", s);
-    exit(1);
-  }
-  fd = open("dirfile/xx", O_CREATE);
-  if(fd >= 0){
-    printf("%s: create dirfile/xx succeeded!\n", s);
-    exit(1);
-  }
-  if(mkdir("dirfile/xx") == 0){
-    printf("%s: mkdir dirfile/xx succeeded!\n", s);
-    exit(1);
-  }
-  if(unlink("dirfile/xx") == 0){
-    printf("%s: unlink dirfile/xx succeeded!\n", s);
-    exit(1);
-  }
-  if(link("README", "dirfile/xx") == 0){
-    printf("%s: link to dirfile/xx succeeded!\n", s);
-    exit(1);
-  }
-  if(unlink("dirfile") != 0){
-    printf("%s: unlink dirfile failed!\n", s);
-    exit(1);
-  }
-
-  fd = open(".", O_RDWR);
-  if(fd >= 0){
-    printf("%s: open . for writing succeeded!\n", s);
-    exit(1);
-  }
-  fd = open(".", 0);
-  if(write(fd, "x", 1) > 0){
-    printf("%s: write . succeeded!\n", s);
-    exit(1);
-  }
-  close(fd);
-}
-
-// test that iput() is called at the end of _namei().
-// also tests empty file names.
-void
-iref(char *s)
-{
-  int i, fd;
-
-  for(i = 0; i < NINODE + 1; i++){
-    if(mkdir("irefd") != 0){
-      printf("%s: mkdir irefd failed\n", s);
-      exit(1);
-    }
-    if(chdir("irefd") != 0){
-      printf("%s: chdir irefd failed\n", s);
-      exit(1);
-    }
-
-    mkdir("");
-    link("README", "");
-    fd = open("", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    fd = open("xx", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    unlink("xx");
-  }
-
-  // clean up
-  for(i = 0; i < NINODE + 1; i++){
-    chdir("..");
-    unlink("irefd");
-  }
-
-  chdir("/");
-}
-
-// test that fork fails gracefully
-// the forktest binary also does this, but it runs out of proc entries first.
-// inside the bigger usertests binary, we run out of memory first.
-void
-forktest(char *s)
-{
-  enum{ N = 1000 };
-  int n, pid;
-
-  for(n=0; n<N; n++){
-    pid = fork();
-    if(pid < 0)
-      break;
-    if(pid == 0)
-      exit(0);
-  }
-
-  if (n == 0) {
-    printf("%s: no fork at all!\n", s);
-    exit(1);
-  }
-
-  if(n == N){
-    printf("%s: fork claimed to work 1000 times!\n", s);
-    exit(1);
-  }
-
-  for(; n > 0; n--){
-    if(wait(0) < 0){
-      printf("%s: wait stopped early\n", s);
-      exit(1);
-    }
-  }
-
-  if(wait(0) != -1){
-    printf("%s: wait got too many\n", s);
-    exit(1);
-  }
-}
-
-void
-sbrkbasic(char *s)
-{
-  enum { TOOMUCH=1024*1024*1024};
-  int i, pid, xstatus;
-  char *c, *a, *b;
-
-  // does sbrk() return the expected failure value?
-  pid = fork();
-  if(pid < 0){
-    printf("fork failed in sbrkbasic\n");
-    exit(1);
-  }
-  if(pid == 0){
-    a = sbrk(TOOMUCH);
-    if(a == (char*)0xffffffffffffffffL){
-      // it's OK if this fails.
-      exit(0);
-    }
-    
-    for(b = a; b < a+TOOMUCH; b += 4096){
-      *b = 99;
-    }
-    
-    // we should not get here! either sbrk(TOOMUCH)
-    // should have failed, or (with lazy allocation)
-    // a pagefault should have killed this process.
-    exit(1);
-  }
-
-  wait(&xstatus);
-  if(xstatus == 1){
-    printf("%s: too much memory allocated!\n", s);
-    exit(1);
-  }
-
-  // can one sbrk() less than a page?
-  a = sbrk(0);
-  for(i = 0; i < 5000; i++){
-    b = sbrk(1);
-    if(b != a){
-      printf("%s: sbrk test failed %d %x %x\n", i, a, b);
-      exit(1);
-    }
-    *b = 1;
-    a = b + 1;
-  }
-  pid = fork();
-  if(pid < 0){
-    printf("%s: sbrk test fork failed\n", s);
-    exit(1);
-  }
-  c = sbrk(1);
-  c = sbrk(1);
-  if(c != a + 1){
-    printf("%s: sbrk test failed post-fork\n", s);
-    exit(1);
-  }
-  if(pid == 0)
-    exit(0);
-  wait(&xstatus);
-  exit(xstatus);
-}
-
-void
-sbrkmuch(char *s)
-{
-  enum { BIG=100*1024*1024 };
-  char *c, *oldbrk, *a, *lastaddr, *p;
-  uint64 amt;
-
-  oldbrk = sbrk(0);
-
-  // can one grow address space to something big?
-  a = sbrk(0);
-  amt = BIG - (uint64)a;
-  p = sbrk(amt);
-  if (p != a) {
-    printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
-    exit(1);
-  }
-
-  // touch each page to make sure it exists.
-  char *eee = sbrk(0);
-  for(char *pp = a; pp < eee; pp += 4096)
-    *pp = 1;
-
-  lastaddr = (char*) (BIG-1);
-  *lastaddr = 99;
-
-  // can one de-allocate?
-  a = sbrk(0);
-  c = sbrk(-PGSIZE);
-  if(c == (char*)0xffffffffffffffffL){
-    printf("%s: sbrk could not deallocate\n", s);
-    exit(1);
-  }
-  c = sbrk(0);
-  if(c != a - PGSIZE){
-    printf("%s: sbrk deallocation produced wrong address, a %x c %x\n", s, a, c);
-    exit(1);
-  }
-
-  // can one re-allocate that page?
-  a = sbrk(0);
-  c = sbrk(PGSIZE);
-  if(c != a || sbrk(0) != a + PGSIZE){
-    printf("%s: sbrk re-allocation failed, a %x c %x\n", s, a, c);
-    exit(1);
-  }
-  if(*lastaddr == 99){
-    // should be zero
-    printf("%s: sbrk de-allocation didn't really deallocate\n", s);
-    exit(1);
-  }
-
-  a = sbrk(0);
-  c = sbrk(-(sbrk(0) - oldbrk));
-  if(c != a){
-    printf("%s: sbrk downsize failed, a %x c %x\n", s, a, c);
-    exit(1);
-  }
-}
-
-// can we read the kernel's memory?
-void
-kernmem(char *s)
-{
-  char *a;
-  int pid;
-
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
-    pid = fork();
-    if(pid < 0){
-      printf("%s: fork failed\n", s);
-      exit(1);
-    }
-    if(pid == 0){
-      printf("%s: oops could read %x = %x\n", s, a, *a);
-      exit(1);
-    }
-    int xstatus;
-    wait(&xstatus);
-    if(xstatus != -1)  // did kernel kill child?
-      exit(1);
-  }
-}
-
-// if we run the system out of memory, does it clean up the last
-// failed allocation?
-void
-sbrkfail(char *s)
-{
-  enum { BIG=100*1024*1024 };
-  int i, xstatus;
-  int fds[2];
-  char scratch;
-  char *c, *a;
-  int pids[10];
-  int pid;
- 
-  if(pipe(fds) != 0){
-    printf("%s: pipe() failed\n", s);
-    exit(1);
-  }
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if((pids[i] = fork()) == 0){
-      // allocate a lot of memory
-      sbrk(BIG - (uint64)sbrk(0));
-      write(fds[1], "x", 1);
-      // sit around until killed
-      for(;;) sleep(1000);
-    }
-    if(pids[i] != -1)
-      read(fds[0], &scratch, 1);
-  }
-
-  // if those failed allocations freed up the pages they did allocate,
-  // we'll be able to allocate here
-  c = sbrk(PGSIZE);
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if(pids[i] == -1)
-      continue;
-    kill(pids[i]);
-    wait(0);
-  }
-  if(c == (char*)0xffffffffffffffffL){
-    printf("%s: failed sbrk leaked memory\n", s);
-    exit(1);
-  }
-
-  // test running fork with the above allocated page 
-  pid = fork();
-  if(pid < 0){
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-  if(pid == 0){
-    // allocate a lot of memory.
-    // this should produce a page fault,
-    // and thus not complete.
-    a = sbrk(0);
-    sbrk(10*BIG);
-    int n = 0;
-    for (i = 0; i < 10*BIG; i += PGSIZE) {
-      n += *(a+i);
-    }
-    // print n so the compiler doesn't optimize away
-    // the for loop.
-    printf("%s: allocate a lot of memory succeeded %d\n", s, n);
-    exit(1);
-  }
-  wait(&xstatus);
-  if(xstatus != -1 && xstatus != 2)
-    exit(1);
-}
+// void
+// bigfile(char *s)
+// {
+//   enum { N = 20, SZ=600 };
+//   int fd, i, total, cc;
+
+//   unlink("bigfile.dat");
+//   fd = open("bigfile.dat", O_CREATE | O_RDWR);
+//   if(fd < 0){
+//     printf("%s: cannot create bigfile", s);
+//     exit(1);
+//   }
+//   for(i = 0; i < N; i++){
+//     memset(buf, i, SZ);
+//     if(write(fd, buf, SZ) != SZ){
+//       printf("%s: write bigfile failed\n", s);
+//       exit(1);
+//     }
+//   }
+//   close(fd);
+
+//   fd = open("bigfile.dat", 0);
+//   if(fd < 0){
+//     printf("%s: cannot open bigfile\n", s);
+//     exit(1);
+//   }
+//   total = 0;
+//   for(i = 0; ; i++){
+//     cc = read(fd, buf, SZ/2);
+//     if(cc < 0){
+//       printf("%s: read bigfile failed\n", s);
+//       exit(1);
+//     }
+//     if(cc == 0)
+//       break;
+//     if(cc != SZ/2){
+//       printf("%s: short read bigfile\n", s);
+//       exit(1);
+//     }
+//     if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
+//       printf("%s: read bigfile wrong data\n", s);
+//       exit(1);
+//     }
+//     total += cc;
+//   }
+//   close(fd);
+//   if(total != N*SZ){
+//     printf("%s: read bigfile wrong total\n", s);
+//     exit(1);
+//   }
+//   unlink("bigfile.dat");
+// }
+
+// void
+// fourteen(char *s)
+// {
+//   int fd;
+
+//   // DIRSIZ is 14.
+
+//   if(mkdir("12345678901234") != 0){
+//     printf("%s: mkdir 12345678901234 failed\n", s);
+//     exit(1);
+//   }
+//   if(mkdir("12345678901234/123456789012345") != 0){
+//     printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
+//     exit(1);
+//   }
+//   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+//   if(fd < 0){
+//     printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+//   fd = open("12345678901234/12345678901234/12345678901234", 0);
+//   if(fd < 0){
+//     printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   if(mkdir("12345678901234/12345678901234") == 0){
+//     printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(mkdir("123456789012345/12345678901234") == 0){
+//     printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
+//     exit(1);
+//   }
+
+//   // clean up
+//   unlink("123456789012345/12345678901234");
+//   unlink("12345678901234/12345678901234");
+//   unlink("12345678901234/12345678901234/12345678901234");
+//   unlink("123456789012345/123456789012345/123456789012345");
+//   unlink("12345678901234/123456789012345");
+//   unlink("12345678901234");
+// }
+
+// void
+// rmdot(char *s)
+// {
+//   if(mkdir("dots") != 0){
+//     printf("%s: mkdir dots failed\n", s);
+//     exit(1);
+//   }
+//   if(chdir("dots") != 0){
+//     printf("%s: chdir dots failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink(".") == 0){
+//     printf("%s: rm . worked!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("..") == 0){
+//     printf("%s: rm .. worked!\n", s);
+//     exit(1);
+//   }
+//   if(chdir("/") != 0){
+//     printf("%s: chdir / failed\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dots/.") == 0){
+//     printf("%s: unlink dots/. worked!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dots/..") == 0){
+//     printf("%s: unlink dots/.. worked!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dots") != 0){
+//     printf("%s: unlink dots failed!\n", s);
+//     exit(1);
+//   }
+// }
+
+// void
+// dirfile(char *s)
+// {
+//   int fd;
+
+//   fd = open("dirfile", O_CREATE);
+//   if(fd < 0){
+//     printf("%s: create dirfile failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+//   if(chdir("dirfile") == 0){
+//     printf("%s: chdir dirfile succeeded!\n", s);
+//     exit(1);
+//   }
+//   fd = open("dirfile/xx", 0);
+//   if(fd >= 0){
+//     printf("%s: create dirfile/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   fd = open("dirfile/xx", O_CREATE);
+//   if(fd >= 0){
+//     printf("%s: create dirfile/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(mkdir("dirfile/xx") == 0){
+//     printf("%s: mkdir dirfile/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dirfile/xx") == 0){
+//     printf("%s: unlink dirfile/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(link("README", "dirfile/xx") == 0){
+//     printf("%s: link to dirfile/xx succeeded!\n", s);
+//     exit(1);
+//   }
+//   if(unlink("dirfile") != 0){
+//     printf("%s: unlink dirfile failed!\n", s);
+//     exit(1);
+//   }
+
+//   fd = open(".", O_RDWR);
+//   if(fd >= 0){
+//     printf("%s: open . for writing succeeded!\n", s);
+//     exit(1);
+//   }
+//   fd = open(".", 0);
+//   if(write(fd, "x", 1) > 0){
+//     printf("%s: write . succeeded!\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+// }
+
+// // test that iput() is called at the end of _namei().
+// // also tests empty file names.
+// void
+// iref(char *s)
+// {
+//   int i, fd;
+
+//   for(i = 0; i < NINODE + 1; i++){
+//     if(mkdir("irefd") != 0){
+//       printf("%s: mkdir irefd failed\n", s);
+//       exit(1);
+//     }
+//     if(chdir("irefd") != 0){
+//       printf("%s: chdir irefd failed\n", s);
+//       exit(1);
+//     }
+
+//     mkdir("");
+//     link("README", "");
+//     fd = open("", O_CREATE);
+//     if(fd >= 0)
+//       close(fd);
+//     fd = open("xx", O_CREATE);
+//     if(fd >= 0)
+//       close(fd);
+//     unlink("xx");
+//   }
+
+//   // clean up
+//   for(i = 0; i < NINODE + 1; i++){
+//     chdir("..");
+//     unlink("irefd");
+//   }
+
+//   chdir("/");
+// }
+
+// // test that fork fails gracefully
+// // the forktest binary also does this, but it runs out of proc entries first.
+// // inside the bigger usertests binary, we run out of memory first.
+// void
+// forktest(char *s)
+// {
+//   enum{ N = 1000 };
+//   int n, pid;
+
+//   for(n=0; n<N; n++){
+//     pid = fork();
+//     if(pid < 0)
+//       break;
+//     if(pid == 0)
+//       exit(0);
+//   }
+
+//   if (n == 0) {
+//     printf("%s: no fork at all!\n", s);
+//     exit(1);
+//   }
+
+//   if(n == N){
+//     printf("%s: fork claimed to work 1000 times!\n", s);
+//     exit(1);
+//   }
+
+//   for(; n > 0; n--){
+//     if(wait(0) < 0){
+//       printf("%s: wait stopped early\n", s);
+//       exit(1);
+//     }
+//   }
+
+//   if(wait(0) != -1){
+//     printf("%s: wait got too many\n", s);
+//     exit(1);
+//   }
+// }
+
+// void
+// sbrkbasic(char *s)
+// {
+//   enum { TOOMUCH=1024*1024*1024};
+//   int i, pid, xstatus;
+//   char *c, *a, *b;
+
+//   // does sbrk() return the expected failure value?
+//   pid = fork();
+//   if(pid < 0){
+//     printf("fork failed in sbrkbasic\n");
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     a = sbrk(TOOMUCH);
+//     if(a == (char*)0xffffffffffffffffL){
+//       // it's OK if this fails.
+//       exit(0);
+//     }
+    
+//     for(b = a; b < a+TOOMUCH; b += 4096){
+//       *b = 99;
+//     }
+    
+//     // we should not get here! either sbrk(TOOMUCH)
+//     // should have failed, or (with lazy allocation)
+//     // a pagefault should have killed this process.
+//     exit(1);
+//   }
+
+//   wait(&xstatus);
+//   if(xstatus == 1){
+//     printf("%s: too much memory allocated!\n", s);
+//     exit(1);
+//   }
+
+//   // can one sbrk() less than a page?
+//   a = sbrk(0);
+//   for(i = 0; i < 5000; i++){
+//     b = sbrk(1);
+//     if(b != a){
+//       printf("%s: sbrk test failed %d %x %x\n", i, a, b);
+//       exit(1);
+//     }
+//     *b = 1;
+//     a = b + 1;
+//   }
+//   pid = fork();
+//   if(pid < 0){
+//     printf("%s: sbrk test fork failed\n", s);
+//     exit(1);
+//   }
+//   c = sbrk(1);
+//   c = sbrk(1);
+//   if(c != a + 1){
+//     printf("%s: sbrk test failed post-fork\n", s);
+//     exit(1);
+//   }
+//   if(pid == 0)
+//     exit(0);
+//   wait(&xstatus);
+//   exit(xstatus);
+// }
+
+// void
+// sbrkmuch(char *s)
+// {
+//   enum { BIG=100*1024*1024 };
+//   char *c, *oldbrk, *a, *lastaddr, *p;
+//   uint64 amt;
+
+//   oldbrk = sbrk(0);
+
+//   // can one grow address space to something big?
+//   a = sbrk(0);
+//   amt = BIG - (uint64)a;
+//   p = sbrk(amt);
+//   if (p != a) {
+//     printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
+//     exit(1);
+//   }
+
+//   // touch each page to make sure it exists.
+//   char *eee = sbrk(0);
+//   for(char *pp = a; pp < eee; pp += 4096)
+//     *pp = 1;
+
+//   lastaddr = (char*) (BIG-1);
+//   *lastaddr = 99;
+
+//   // can one de-allocate?
+//   a = sbrk(0);
+//   c = sbrk(-PGSIZE);
+//   if(c == (char*)0xffffffffffffffffL){
+//     printf("%s: sbrk could not deallocate\n", s);
+//     exit(1);
+//   }
+//   c = sbrk(0);
+//   if(c != a - PGSIZE){
+//     printf("%s: sbrk deallocation produced wrong address, a %x c %x\n", s, a, c);
+//     exit(1);
+//   }
+
+//   // can one re-allocate that page?
+//   a = sbrk(0);
+//   c = sbrk(PGSIZE);
+//   if(c != a || sbrk(0) != a + PGSIZE){
+//     printf("%s: sbrk re-allocation failed, a %x c %x\n", s, a, c);
+//     exit(1);
+//   }
+//   if(*lastaddr == 99){
+//     // should be zero
+//     printf("%s: sbrk de-allocation didn't really deallocate\n", s);
+//     exit(1);
+//   }
+
+//   a = sbrk(0);
+//   c = sbrk(-(sbrk(0) - oldbrk));
+//   if(c != a){
+//     printf("%s: sbrk downsize failed, a %x c %x\n", s, a, c);
+//     exit(1);
+//   }
+// }
+
+// // can we read the kernel's memory?
+// void
+// kernmem(char *s)
+// {
+//   char *a;
+//   int pid;
+
+//   for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+//     pid = fork();
+//     if(pid < 0){
+//       printf("%s: fork failed\n", s);
+//       exit(1);
+//     }
+//     if(pid == 0){
+//       printf("%s: oops could read %x = %x\n", s, a, *a);
+//       exit(1);
+//     }
+//     int xstatus;
+//     wait(&xstatus);
+//     if(xstatus != -1)  // did kernel kill child?
+//       exit(1);
+//   }
+// }
+
+// // if we run the system out of memory, does it clean up the last
+// // failed allocation?
+// void
+// sbrkfail(char *s)
+// {
+//   enum { BIG=100*1024*1024 };
+//   int i, xstatus;
+//   int fds[2];
+//   char scratch;
+//   char *c, *a;
+//   int pids[10];
+//   int pid;
+ 
+//   if(pipe(fds) != 0){
+//     printf("%s: pipe() failed\n", s);
+//     exit(1);
+//   }
+//   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+//     if((pids[i] = fork()) == 0){
+//       // allocate a lot of memory
+//       sbrk(BIG - (uint64)sbrk(0));
+//       write(fds[1], "x", 1);
+//       // sit around until killed
+//       for(;;) sleep(1000);
+//     }
+//     if(pids[i] != -1)
+//       read(fds[0], &scratch, 1);
+//   }
+
+//   // if those failed allocations freed up the pages they did allocate,
+//   // we'll be able to allocate here
+//   c = sbrk(PGSIZE);
+//   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+//     if(pids[i] == -1)
+//       continue;
+//     kill(pids[i]);
+//     wait(0);
+//   }
+//   if(c == (char*)0xffffffffffffffffL){
+//     printf("%s: failed sbrk leaked memory\n", s);
+//     exit(1);
+//   }
+
+//   // test running fork with the above allocated page 
+//   pid = fork();
+//   if(pid < 0){
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     // allocate a lot of memory.
+//     // this should produce a page fault,
+//     // and thus not complete.
+//     a = sbrk(0);
+//     sbrk(10*BIG);
+//     int n = 0;
+//     for (i = 0; i < 10*BIG; i += PGSIZE) {
+//       n += *(a+i);
+//     }
+//     // print n so the compiler doesn't optimize away
+//     // the for loop.
+//     printf("%s: allocate a lot of memory succeeded %d\n", s, n);
+//     exit(1);
+//   }
+//   wait(&xstatus);
+//   if(xstatus != -1 && xstatus != 2)
+//     exit(1);
+// }
 
   
-// test reads/writes from/to allocated memory
-void
-sbrkarg(char *s)
-{
-  char *a;
-  int fd, n;
-
-  a = sbrk(PGSIZE);
-  fd = open("sbrk", O_CREATE|O_WRONLY);
-  unlink("sbrk");
-  if(fd < 0)  {
-    printf("%s: open sbrk failed\n", s);
-    exit(1);
-  }
-  if ((n = write(fd, a, PGSIZE)) < 0) {
-    printf("%s: write sbrk failed\n", s);
-    exit(1);
-  }
-  close(fd);
-
-  // test writes to allocated memory
-  a = sbrk(PGSIZE);
-  if(pipe((int *) a) != 0){
-    printf("%s: pipe() failed\n", s);
-    exit(1);
-  } 
-}
-
-void
-validatetest(char *s)
-{
-  int hi;
-  uint64 p;
-
-  hi = 1100*1024;
-  for(p = 0; p <= (uint)hi; p += PGSIZE){
-    // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
-      printf("%s: link should not succeed\n", s);
-      exit(1);
-    }
-  }
-}
-
-// does unintialized data start out zero?
-char uninit[10000];
-void
-bsstest(char *s)
-{
-  int i;
-
-  for(i = 0; i < sizeof(uninit); i++){
-    if(uninit[i] != '\0'){
-      printf("%s: bss test failed\n", s);
-      exit(1);
-    }
-  }
-}
-
-// does exec return an error if the arguments
-// are larger than a page? or does it write
-// below the stack and wreck the instructions/data?
-void
-bigargtest(char *s)
-{
-  int pid, fd, xstatus;
-
-  unlink("bigarg-ok");
-  pid = fork();
-  if(pid == 0){
-    static char *args[MAXARG];
-    int i;
-    for(i = 0; i < MAXARG-1; i++)
-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    args[MAXARG-1] = 0;
-    exec("echo", args);
-    fd = open("bigarg-ok", O_CREATE);
-    close(fd);
-    exit(0);
-  } else if(pid < 0){
-    printf("%s: bigargtest: fork failed\n", s);
-    exit(1);
-  }
+// // test reads/writes from/to allocated memory
+// void
+// sbrkarg(char *s)
+// {
+//   char *a;
+//   int fd, n;
+
+//   a = sbrk(PGSIZE);
+//   fd = open("sbrk", O_CREATE|O_WRONLY);
+//   unlink("sbrk");
+//   if(fd < 0)  {
+//     printf("%s: open sbrk failed\n", s);
+//     exit(1);
+//   }
+//   if ((n = write(fd, a, PGSIZE)) < 0) {
+//     printf("%s: write sbrk failed\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+
+//   // test writes to allocated memory
+//   a = sbrk(PGSIZE);
+//   if(pipe((int *) a) != 0){
+//     printf("%s: pipe() failed\n", s);
+//     exit(1);
+//   } 
+// }
+
+// void
+// validatetest(char *s)
+// {
+//   int hi;
+//   uint64 p;
+
+//   hi = 1100*1024;
+//   for(p = 0; p <= (uint)hi; p += PGSIZE){
+//     // try to crash the kernel by passing in a bad string pointer
+//     if(link("nosuchfile", (char*)p) != -1){
+//       printf("%s: link should not succeed\n", s);
+//       exit(1);
+//     }
+//   }
+// }
+
+// // does unintialized data start out zero?
+// char uninit[10000];
+// void
+// bsstest(char *s)
+// {
+//   int i;
+
+//   for(i = 0; i < sizeof(uninit); i++){
+//     if(uninit[i] != '\0'){
+//       printf("%s: bss test failed\n", s);
+//       exit(1);
+//     }
+//   }
+// }
+
+// // does exec return an error if the arguments
+// // are larger than a page? or does it write
+// // below the stack and wreck the instructions/data?
+// void
+// bigargtest(char *s)
+// {
+//   int pid, fd, xstatus;
+
+//   unlink("bigarg-ok");
+//   pid = fork();
+//   if(pid == 0){
+//     static char *args[MAXARG];
+//     int i;
+//     for(i = 0; i < MAXARG-1; i++)
+//       args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+//     args[MAXARG-1] = 0;
+//     exec("echo", args);
+//     fd = open("bigarg-ok", O_CREATE);
+//     close(fd);
+//     exit(0);
+//   } else if(pid < 0){
+//     printf("%s: bigargtest: fork failed\n", s);
+//     exit(1);
+//   }
   
-  wait(&xstatus);
-  if(xstatus != 0)
-    exit(xstatus);
-  fd = open("bigarg-ok", 0);
-  if(fd < 0){
-    printf("%s: bigarg test failed!\n", s);
-    exit(1);
-  }
-  close(fd);
-}
-
-// what happens when the file system runs out of blocks?
-// answer: balloc panics, so this test is not useful.
-void
-fsfull()
-{
-  int nfiles;
-  int fsblocks = 0;
-
-  printf("fsfull test\n");
-
-  for(nfiles = 0; ; nfiles++){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    printf("writing %s\n", name);
-    int fd = open(name, O_CREATE|O_RDWR);
-    if(fd < 0){
-      printf("open %s failed\n", name);
-      break;
-    }
-    int total = 0;
-    while(1){
-      int cc = write(fd, buf, BSIZE);
-      if(cc < BSIZE)
-        break;
-      total += cc;
-      fsblocks++;
-    }
-    printf("wrote %d bytes\n", total);
-    close(fd);
-    if(total == 0)
-      break;
-  }
-
-  while(nfiles >= 0){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    unlink(name);
-    nfiles--;
-  }
-
-  printf("fsfull test finished\n");
-}
-
-void argptest(char *s)
-{
-  int fd;
-  fd = open("init", O_RDONLY);
-  if (fd < 0) {
-    printf("%s: open failed\n", s);
-    exit(1);
-  }
-  read(fd, sbrk(0) - 1, -1);
-  close(fd);
-}
-
-unsigned long randstate = 1;
-unsigned int
-rand()
-{
-  randstate = randstate * 1664525 + 1013904223;
-  return randstate;
-}
-
-// check that there's an invalid page beneath
-// the user stack, to catch stack overflow.
-void
-stacktest(char *s)
-{
-  int pid;
-  int xstatus;
+//   wait(&xstatus);
+//   if(xstatus != 0)
+//     exit(xstatus);
+//   fd = open("bigarg-ok", 0);
+//   if(fd < 0){
+//     printf("%s: bigarg test failed!\n", s);
+//     exit(1);
+//   }
+//   close(fd);
+// }
+
+// // what happens when the file system runs out of blocks?
+// // answer: balloc panics, so this test is not useful.
+// void
+// fsfull()
+// {
+//   int nfiles;
+//   int fsblocks = 0;
+
+//   printf("fsfull test\n");
+
+//   for(nfiles = 0; ; nfiles++){
+//     char name[64];
+//     name[0] = 'f';
+//     name[1] = '0' + nfiles / 1000;
+//     name[2] = '0' + (nfiles % 1000) / 100;
+//     name[3] = '0' + (nfiles % 100) / 10;
+//     name[4] = '0' + (nfiles % 10);
+//     name[5] = '\0';
+//     printf("writing %s\n", name);
+//     int fd = open(name, O_CREATE|O_RDWR);
+//     if(fd < 0){
+//       printf("open %s failed\n", name);
+//       break;
+//     }
+//     int total = 0;
+//     while(1){
+//       int cc = write(fd, buf, BSIZE);
+//       if(cc < BSIZE)
+//         break;
+//       total += cc;
+//       fsblocks++;
+//     }
+//     printf("wrote %d bytes\n", total);
+//     close(fd);
+//     if(total == 0)
+//       break;
+//   }
+
+//   while(nfiles >= 0){
+//     char name[64];
+//     name[0] = 'f';
+//     name[1] = '0' + nfiles / 1000;
+//     name[2] = '0' + (nfiles % 1000) / 100;
+//     name[3] = '0' + (nfiles % 100) / 10;
+//     name[4] = '0' + (nfiles % 10);
+//     name[5] = '\0';
+//     unlink(name);
+//     nfiles--;
+//   }
+
+//   printf("fsfull test finished\n");
+// }
+
+// void argptest(char *s)
+// {
+//   int fd;
+//   fd = open("init", O_RDONLY);
+//   if (fd < 0) {
+//     printf("%s: open failed\n", s);
+//     exit(1);
+//   }
+//   read(fd, sbrk(0) - 1, -1);
+//   close(fd);
+// }
+
+// unsigned long randstate = 1;
+// unsigned int
+// rand()
+// {
+//   randstate = randstate * 1664525 + 1013904223;
+//   return randstate;
+// }
+
+// // check that there's an invalid page beneath
+// // the user stack, to catch stack overflow.
+// void
+// stacktest(char *s)
+// {
+//   int pid;
+//   int xstatus;
   
-  pid = fork();
-  if(pid == 0) {
-    char *sp = (char *) r_sp();
-    sp -= PGSIZE;
-    // the *sp should cause a trap.
-    printf("%s: stacktest: read below stack %p\n", s, *sp);
-    exit(1);
-  } else if(pid < 0){
-    printf("%s: fork failed\n", s);
-    exit(1);
-  }
-  wait(&xstatus);
-  if(xstatus == -1)  // kernel killed child?
-    exit(0);
-  else
-    exit(xstatus);
-}
-
-// regression test. copyin(), copyout(), and copyinstr() used to cast
-// the virtual page address to uint, which (with certain wild system
-// call arguments) resulted in a kernel page faults.
-void
-pgbug(char *s)
-{
-  char *argv[1];
-  argv[0] = 0;
-  exec((char*)0xeaeb0b5b00002f5e, argv);
-
-  pipe((int*)0xeaeb0b5b00002f5e);
-
-  exit(0);
-}
-
-// regression test. does the kernel panic if a process sbrk()s its
-// size to be less than a page, or zero, or reduces the break by an
-// amount too small to cause a page to be freed?
-void
-sbrkbugs(char *s)
-{
-  int pid = fork();
-  if(pid < 0){
-    printf("fork failed\n");
-    exit(1);
-  }
-  if(pid == 0){
-    int sz = (uint64) sbrk(0);
-    // free all user memory; there used to be a bug that
-    // would not adjust p->sz correctly in this case,
-    // causing exit() to panic.
-    sbrk(-sz);
-    // user page fault here.
-    exit(0);
-  }
-  wait(0);
-
-  pid = fork();
-  if(pid < 0){
-    printf("fork failed\n");
-    exit(1);
-  }
-  if(pid == 0){
-    int sz = (uint64) sbrk(0);
-    // set the break to somewhere in the very first
-    // page; there used to be a bug that would incorrectly
-    // free the first page.
-    sbrk(-(sz - 3500));
-    exit(0);
-  }
-  wait(0);
-
-  pid = fork();
-  if(pid < 0){
-    printf("fork failed\n");
-    exit(1);
-  }
-  if(pid == 0){
-    // set the break in the middle of a page.
-    sbrk((10*4096 + 2048) - (uint64)sbrk(0));
-
-    // reduce the break a bit, but not enough to
-    // cause a page to be freed. this used to cause
-    // a panic.
-    sbrk(-10);
-
-    exit(0);
-  }
-  wait(0);
-
-  exit(0);
-}
-
-// regression test. does write() with an invalid buffer pointer cause
-// a block to be allocated for a file that is then not freed when the
-// file is deleted? if the kernel has this bug, it will panic: balloc:
-// out of blocks. assumed_free may need to be raised to be more than
-// the number of free blocks. this test takes a long time.
-void
-badwrite(char *s)
-{
-  int assumed_free = 600;
+//   pid = fork();
+//   if(pid == 0) {
+//     char *sp = (char *) r_sp();
+//     sp -= PGSIZE;
+//     // the *sp should cause a trap.
+//     printf("%s: stacktest: read below stack %p\n", s, *sp);
+//     exit(1);
+//   } else if(pid < 0){
+//     printf("%s: fork failed\n", s);
+//     exit(1);
+//   }
+//   wait(&xstatus);
+//   if(xstatus == -1)  // kernel killed child?
+//     exit(0);
+//   else
+//     exit(xstatus);
+// }
+
+// // regression test. copyin(), copyout(), and copyinstr() used to cast
+// // the virtual page address to uint, which (with certain wild system
+// // call arguments) resulted in a kernel page faults.
+// void
+// pgbug(char *s)
+// {
+//   char *argv[1];
+//   argv[0] = 0;
+//   exec((char*)0xeaeb0b5b00002f5e, argv);
+
+//   pipe((int*)0xeaeb0b5b00002f5e);
+
+//   exit(0);
+// }
+
+// // regression test. does the kernel panic if a process sbrk()s its
+// // size to be less than a page, or zero, or reduces the break by an
+// // amount too small to cause a page to be freed?
+// void
+// sbrkbugs(char *s)
+// {
+//   int pid = fork();
+//   if(pid < 0){
+//     printf("fork failed\n");
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     int sz = (uint64) sbrk(0);
+//     // free all user memory; there used to be a bug that
+//     // would not adjust p->sz correctly in this case,
+//     // causing exit() to panic.
+//     sbrk(-sz);
+//     // user page fault here.
+//     exit(0);
+//   }
+//   wait(0);
+
+//   pid = fork();
+//   if(pid < 0){
+//     printf("fork failed\n");
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     int sz = (uint64) sbrk(0);
+//     // set the break to somewhere in the very first
+//     // page; there used to be a bug that would incorrectly
+//     // free the first page.
+//     sbrk(-(sz - 3500));
+//     exit(0);
+//   }
+//   wait(0);
+
+//   pid = fork();
+//   if(pid < 0){
+//     printf("fork failed\n");
+//     exit(1);
+//   }
+//   if(pid == 0){
+//     // set the break in the middle of a page.
+//     sbrk((10*4096 + 2048) - (uint64)sbrk(0));
+
+//     // reduce the break a bit, but not enough to
+//     // cause a page to be freed. this used to cause
+//     // a panic.
+//     sbrk(-10);
+
+//     exit(0);
+//   }
+//   wait(0);
+
+//   exit(0);
+// }
+
+// // regression test. does write() with an invalid buffer pointer cause
+// // a block to be allocated for a file that is then not freed when the
+// // file is deleted? if the kernel has this bug, it will panic: balloc:
+// // out of blocks. assumed_free may need to be raised to be more than
+// // the number of free blocks. this test takes a long time.
+// void
+// badwrite(char *s)
+// {
+//   int assumed_free = 600;
   
-  unlink("junk");
-  for(int i = 0; i < assumed_free; i++){
-    int fd = open("junk", O_CREATE|O_WRONLY);
-    if(fd < 0){
-      printf("open junk failed\n");
-      exit(1);
-    }
-    write(fd, (char*)0xffffffffffL, 1);
-    close(fd);
-    unlink("junk");
-  }
-
-  int fd = open("junk", O_CREATE|O_WRONLY);
-  if(fd < 0){
-    printf("open junk failed\n");
-    exit(1);
-  }
-  if(write(fd, "x", 1) != 1){
-    printf("write failed\n");
-    exit(1);
-  }
-  close(fd);
-  unlink("junk");
-
-  exit(0);
-}
-
-// regression test. test whether exec() leaks memory if one of the
-// arguments is invalid. the test passes if the kernel doesn't panic.
-void
-badarg(char *s)
-{
-  for(int i = 0; i < 50000; i++){
-    char *argv[2];
-    argv[0] = (char*)0xffffffff;
-    argv[1] = 0;
-    exec("echo", argv);
-  }
+//   unlink("junk");
+//   for(int i = 0; i < assumed_free; i++){
+//     int fd = open("junk", O_CREATE|O_WRONLY);
+//     if(fd < 0){
+//       printf("open junk failed\n");
+//       exit(1);
+//     }
+//     write(fd, (char*)0xffffffffffL, 1);
+//     close(fd);
+//     unlink("junk");
+//   }
+
+//   int fd = open("junk", O_CREATE|O_WRONLY);
+//   if(fd < 0){
+//     printf("open junk failed\n");
+//     exit(1);
+//   }
+//   if(write(fd, "x", 1) != 1){
+//     printf("write failed\n");
+//     exit(1);
+//   }
+//   close(fd);
+//   unlink("junk");
+
+//   exit(0);
+// }
+
+// // regression test. test whether exec() leaks memory if one of the
+// // arguments is invalid. the test passes if the kernel doesn't panic.
+// void
+// badarg(char *s)
+// {
+//   for(int i = 0; i < 50000; i++){
+//     char *argv[2];
+//     argv[0] = (char*)0xffffffff;
+//     argv[1] = 0;
+//     exec("echo", argv);
+//   }
   
-  exit(0);
-}
-
-// test the exec() code that cleans up if it runs out
-// of memory. it's really a test that such a condition
-// doesn't cause a panic.
-void
-execout(char *s)
-{
-  for(int avail = 0; avail < 15; avail++){
-    int pid = fork();
-    if(pid < 0){
-      printf("fork failed\n");
-      exit(1);
-    } else if(pid == 0){
-      // allocate all of memory.
-      while(1){
-        uint64 a = (uint64) sbrk(4096);
-        if(a == 0xffffffffffffffffLL)
-          break;
-        *(char*)(a + 4096 - 1) = 1;
-      }
-
-      // free a few pages, in order to let exec() make some
-      // progress.
-      for(int i = 0; i < avail; i++)
-        sbrk(-4096);
+//   exit(0);
+// }
+
+// // test the exec() code that cleans up if it runs out
+// // of memory. it's really a test that such a condition
+// // doesn't cause a panic.
+// void
+// execout(char *s)
+// {
+//   for(int avail = 0; avail < 15; avail++){
+//     int pid = fork();
+//     if(pid < 0){
+//       printf("fork failed\n");
+//       exit(1);
+//     } else if(pid == 0){
+//       // allocate all of memory.
+//       while(1){
+//         uint64 a = (uint64) sbrk(4096);
+//         if(a == 0xffffffffffffffffLL)
+//           break;
+//         *(char*)(a + 4096 - 1) = 1;
+//       }
+
+//       // free a few pages, in order to let exec() make some
+//       // progress.
+//       for(int i = 0; i < avail; i++)
+//         sbrk(-4096);
       
-      close(1);
-      char *args[] = { "echo", "x", 0 };
-      exec("echo", args);
-      exit(0);
-    } else {
-      wait((int*)0);
-    }
-  }
-
-  exit(0);
-}
-
-//
+//       close(1);
+//       char *args[] = { "echo", "x", 0 };
+//       exec("echo", args);
+//       exit(0);
+//     } else {
+//       wait((int*)0);
+//     }
+//   }
+
+//   exit(0);
+// }
+
+// //
 // use sbrk() to count how many free physical memory pages there are.
 // touches the pages to force allocation.
 // because out of memory with lazy allocation results in the process
@@ -2767,65 +2768,65 @@ main(int argc, char *argv[])
     char *s;
   } tests[] = {
     {manywrites, "manywrites"},
-    {execout, "execout"},
-    {copyin, "copyin"},
-    {copyout, "copyout"},
-    {copyinstr1, "copyinstr1"},
-    {copyinstr2, "copyinstr2"},
-    {copyinstr3, "copyinstr3"},
-    {rwsbrk, "rwsbrk" },
-    {truncate1, "truncate1"},
-    {truncate2, "truncate2"},
-    {truncate3, "truncate3"},
-    {reparent2, "reparent2"},
-    {pgbug, "pgbug" },
-    {sbrkbugs, "sbrkbugs" },
-    // {badwrite, "badwrite" },
-    {badarg, "badarg" },
-    {reparent, "reparent" },
-    {twochildren, "twochildren"},
-    {forkfork, "forkfork"},
-    {forkforkfork, "forkforkfork"},
-    {argptest, "argptest"},
-    {createdelete, "createdelete"},
-    {linkunlink, "linkunlink"},
-    {linktest, "linktest"},
-    {unlinkread, "unlinkread"},
-    {concreate, "concreate"},
-    {subdir, "subdir"},
-    {fourfiles, "fourfiles"},
-    {sharedfd, "sharedfd"},
-    {dirtest, "dirtest"},
-    {exectest, "exectest"},
-    {bigargtest, "bigargtest"},
-    {bigwrite, "bigwrite"},
-    {bsstest, "bsstest"},
-    {sbrkbasic, "sbrkbasic"},
-    {sbrkmuch, "sbrkmuch"},
-    {kernmem, "kernmem"},
-    {sbrkfail, "sbrkfail"},
-    {sbrkarg, "sbrkarg"},
-    {validatetest, "validatetest"},
-    {stacktest, "stacktest"},
-    {opentest, "opentest"},
-    {writetest, "writetest"},
-    {writebig, "writebig"},
-    {createtest, "createtest"},
-    {openiputtest, "openiput"},
-    {exitiputtest, "exitiput"},
-    {iputtest, "iput"},
-    {mem, "mem"},
-    {pipe1, "pipe1"},
-    {killstatus, "killstatus"},
-    {preempt, "preempt"},
-    {exitwait, "exitwait"},
-    {rmdot, "rmdot"},
-    {fourteen, "fourteen"},
-    {bigfile, "bigfile"},
-    {dirfile, "dirfile"},
-    {iref, "iref"},
-    {forktest, "forktest"},
-    {bigdir, "bigdir"}, // slow
+    // {execout, "execout"},
+    // {copyin, "copyin"},
+    // {copyout, "copyout"},
+    // {copyinstr1, "copyinstr1"},
+    // {copyinstr2, "copyinstr2"},
+    // {copyinstr3, "copyinstr3"},
+    // {rwsbrk, "rwsbrk" },
+    // {truncate1, "truncate1"},
+    // {truncate2, "truncate2"},
+    // {truncate3, "truncate3"},
+    // {reparent2, "reparent2"},
+    // {pgbug, "pgbug" },
+    // {sbrkbugs, "sbrkbugs" },
+    // // {badwrite, "badwrite" },
+    // {badarg, "badarg" },
+    // {reparent, "reparent" },
+    // {twochildren, "twochildren"},
+    // {forkfork, "forkfork"},
+    // {forkforkfork, "forkforkfork"},
+    // {argptest, "argptest"},
+    // {createdelete, "createdelete"},
+    // {linkunlink, "linkunlink"},
+    // {linktest, "linktest"},
+    // {unlinkread, "unlinkread"},
+    // {concreate, "concreate"},
+    // {subdir, "subdir"},
+    // {fourfiles, "fourfiles"},
+    // {sharedfd, "sharedfd"},
+    // {dirtest, "dirtest"},
+    // {exectest, "exectest"},
+    // {bigargtest, "bigargtest"},
+    // {bigwrite, "bigwrite"},
+    // {bsstest, "bsstest"},
+    // {sbrkbasic, "sbrkbasic"},
+    // {sbrkmuch, "sbrkmuch"},
+    // {kernmem, "kernmem"},
+    // {sbrkfail, "sbrkfail"},
+    // {sbrkarg, "sbrkarg"},
+    // {validatetest, "validatetest"},
+    // {stacktest, "stacktest"},
+    // {opentest, "opentest"},
+    // {writetest, "writetest"},
+    // {writebig, "writebig"},
+    // {createtest, "createtest"},
+    // {openiputtest, "openiput"},
+    // {exitiputtest, "exitiput"},
+    // {iputtest, "iput"},
+    // {mem, "mem"},
+    // {pipe1, "pipe1"},
+    // {killstatus, "killstatus"},
+    // {preempt, "preempt"},
+    // {exitwait, "exitwait"},
+    // {rmdot, "rmdot"},
+    // {fourteen, "fourteen"},
+    // {bigfile, "bigfile"},
+    // {dirfile, "dirfile"},
+    // {iref, "iref"},
+    // {forktest, "forktest"},
+    // {bigdir, "bigdir"}, // slow
     { 0, 0},
   };
 
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..dae464e 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,6 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("count_pages");
+entry("pagefault");
+entry("flipPageTracePrintFlag");
